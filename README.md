# ze: A Minimal, Fast, Emacs-like Editor

**ze** — "Zig Editor" または "Zero-latency Editor"

> mgとUnix哲学にインスパイアされた、高速で最小限のテキストエディタ。
> Zigで実装。Emacsキーバインディング。シェル統合。

## Quick Start

```bash
# ビルド
zig build -Doptimize=ReleaseSafe

# 実行
./zig-out/bin/ze [filename]
```

---

## Vision

**zeは「SSH先で即使える、設定不要のモダンなエディタ」を目指しています。**

### コンセプト
- **ゼロコンフィグ**: dotfileなし、インストール後即使用可能
- **シングルバイナリ**: 依存なし、5MB以下、どこでもコピーして動く
- **SSH先での編集**: vimほど複雑でなく、nanoより高機能で綺麗
- **Emacsライク**: Ctrl-n/p/f/b等のキーバインドでBash/Readline使いにも自然
- **モダンで綺麗**: UTF-8完全対応、見た目も快適（24bit色は将来対応予定）

### ポジショニング

| エディタ | サイズ | 起動 | 学習コスト | 設定 | 見た目 |
|---------|-------|------|-----------|------|--------|
| vim | 3MB | 速い | 高い | 必要 | 古い |
| nano | 200KB | 速い | 低い | 不要 | 古い |
| micro | 8MB | 普通 | 低い | 任意 | 普通 |
| helix | 15MB | 遅い | 中 | 任意 | モダン |
| **ze** | **5MB** | **爆速** | **低い** | **不要** | **モダン** |

### 使用場面
- サーバーのログファイル編集
- 設定ファイルのクイック修正
- ちょっとしたスクリプト編集
- Git commit message編集
- SSH先での日常的な編集作業

**目指すのは「IDEではなく、日常使いのエディタ」**

---

## Philosophy

1. **Speed** — 8ms以下の入力レイテンシ。ゲームレベルの応答性。
2. **Minimal** — 一つのことを上手く行う。余分な機能なし。
3. **Unix** — テキストはストリーム。パイプはファーストクラス。
4. **Short** — コマンドは簡潔。`shell-command-on-region`のような冗長さはなし。

---

## Architecture Overview

```
┌─────────────────────────────────────────────────────┐
│                    Input Thread                     │
│              (epoll/kqueue, lock-free)              │
└────────────────────────┬────────────────────────────┘
                         ▼
┌─────────────────────────────────────────────────────┐
│                 Command Dispatch                    │
│              (comptime keymap table)                │
└────────────────────────┬────────────────────────────┘
                         ▼
┌─────────────────────────────────────────────────────┐
│                  Editor (複数管理)                  │
│   buffers: ArrayList(*BufferState)                  │
│   windows: ArrayList(Window)                        │
└────────┬─────────────────────────────┬──────────────┘
         ▼                             ▼
┌──────────────────────┐    ┌──────────────────────┐
│    BufferState       │    │      Window          │
│  (ヒープ割り当て)    │    │   (値型)             │
│  - buffer (PieceTable)│   │  - view              │
│  - filename          │◄───│  - buffer_id (参照) │
│  - modified          │    │  - position/size     │
│  - readonly          │    │  - mark_pos          │
│  - undo/redo stack   │    │                      │
└──────────────────────┘    └──────────────────────┘
         │
         ▼
┌─────────────────────────────────────────────────────┐
│                      Buffer                         │
│        (Piece Table + B-tree line index)            │
│   UTF-8+LF: mmap原本 / それ以外: 変換後コピー       │
│        **内部表現: UTF-8 + LF (常に正規化)**        │
└────────────────────────┬────────────────────────────┘
                         ▼
┌─────────────────────────────────────────────────────┐
│                       View                          │
│     (double-buffer cells, diff-only rendering)      │
└────────────────────────┬────────────────────────────┘
                         ▼
┌─────────────────────────────────────────────────────┐
│                     Terminal                        │
│              (batched write, 1 syscall)             │
└─────────────────────────────────────────────────────┘
```

### マルチバッファ/マルチウィンドウアーキテクチャ

- **BufferState**: ヒープ割り当てされたバッファの状態を保持
  - Piece Tableバッファの実体
  - ファイル名、変更フラグ、読み取り専用フラグ
  - Undo/Redoスタック
  - 一意なbuffer_idで識別

- **Window**: 表示とカーソル位置を管理する値型
  - View（画面描画状態）
  - buffer_id参照（どのバッファを表示するか）
  - カーソル位置、マーク位置、スクロール位置

- **分離の利点**:
  - 複数のウィンドウで同じバッファを表示可能（将来）
  - バッファのライフサイクルとウィンドウのライフサイクルを独立管理
  - メモリ効率の向上（バッファデータの共有）

### エンコーディング・改行コードの処理方針

**基本設計**: 内部は常に UTF-8 + LF で保持し、I/O時のみ変換

> **zeはUTF-8 + LFに最適化されています。**
>
> Unix/macOSのCLI環境で最大限のパフォーマンスを発揮します。
> UTF-8 + LFファイルはmmapによるゼロコピー読み込みで爆速。
> それ以外（UTF-16、CRLF等）も動作しますが、変換コストがかかります。
>
> **設計思想**: レガシー文字コードやWindowsのCRLFに振り回されない。
> zeは「Unix/macOSでサクッと編集するためのツール」です。

```
アーキテクチャ:

  ┌─────────────────────────────────────────────────┐
  │  高速パス（mmap）: UTF-8 + LF のみ              │
  │    → ゼロコピー、1GBでも瞬時にオープン         │
  ├─────────────────────────────────────────────────┤
  │  フォールバックパス: それ以外すべて             │
  │    - UTF-8 BOM / UTF-16 LE/BE                   │
  │    - CRLF / CR                                  │
  │    - Shift_JIS / EUC-JP（将来サポート時）       │
  │    → 読み込み + 変換（遅いがOK）               │
  └─────────────────────────────────────────────────┘
                        ↓
  ┌─────────────────────────────────────────────────┐
  │  内部表現: 常に UTF-8 + LF                      │
  │    - すべての編集操作はここで実行               │
  │    - エンコーディングを意識する必要なし         │
  └─────────────────────────────────────────────────┘
                        ↓
  ┌─────────────────────────────────────────────────┐
  │  保存時: 元のエンコーディング・改行に復元       │
  └─────────────────────────────────────────────────┘

ポイント:
  - mmapは絶対にUTF-8+LFだけ（シンプルさ維持）
  - レガシーサポートを追加してもアーキテクチャは変わらない
  - 99%のUnix/macOSファイルは高速パスを通る
```

**現在の対応状況** (Phase 2完了):
- ✅ **UTF-8 + LF（高速パス）**: mmap による直接マッピング
  - ファイルをメモリにコピーせず直接参照
  - 1GBファイルでも瞬時にオープン
- ✅ **エンコーディング（フォールバック）**: 以下を完全サポート
  - UTF-8 BOM
  - UTF-16LE BOM
  - UTF-16BE BOM
  - 読み込み時に自動検出→UTF-8変換
  - 保存時に元のエンコーディングで出力（BOM含む）
  - ステータスラインに表示
- ✅ **改行コード**: LF/CRLF/CR 自動検出・保持
  - 読み込み時に LF に正規化
  - 保存時に検出した改行コードで出力
  - ステータスラインに表示 (LF/CRLF/CR)
- ✅ **レガシー日本語エンコーディング対応**:
  - Shift_JIS → UTF-8 自動変換
  - EUC-JP → UTF-8 自動変換
  - ヒューリスティック検出で自動判別
  - ひらがな・カタカナ・主要漢字対応

---

## Performance Targets

| 指標 | 目標値 |
|--------|--------|
| 起動時間 | < 10ms |
| キー入力から画面更新 | < 8ms (125fps) |
| ファイルオープン (1GB) | < 100ms |
| 検索速度 (1GB) | > 2GB/s |
| メモリオーバーヘッド | ファイルサイズの約10% |

---

## Data Structures

### Buffer: Piece Table + B-tree

```
Original File (readToEndAlloc):
┌─────────────────────────────────────────────────┐
│ The quick brown fox jumps over the lazy dog.   │
└─────────────────────────────────────────────────┘

Add Buffer (arena, append-only):
┌─────────────────┐
│ FAST            │
└─────────────────┘

Piece Table:
┌──────────────────────────────────────────────────┐
│ (orig, 0, 10) → (add, 0, 4) → (orig, 16, 28)    │
│ "The quick " + "FAST" + " fox jumps..."          │
└──────────────────────────────────────────────────┘

B-tree Index:
  - 行番号 → pieceオフセット (遅延、オンデマンド)
  - 影響範囲のみ再構築
```

### Memory Strategy

| コンポーネント | アロケータ |
|-----------|-----------|
| 元ファイル | readToEndAlloc (将来 mmap 予定) |
| 追加バッファ | Arena (フラグメンテーションなし) |
| Undoスタック | Piece参照 (コピーなし) |
| レンダーバッファ | 固定バッファ |
| 検索結果 | 一時Arena (クエリごと) |

---

## Input System

### Goals

- 専用入力スレッド
- メインループでブロッキングなし
- メインスレッドへのロックフリーキュー
- 自前のキーリピート管理（OS経由なし）

### Implementation

```zig
const InputEvent = struct {
    key: Key,
    timestamp: i128,  // レイテンシ追跡用
};

// 入力スレッド
fn inputLoop(queue: *LockFreeQueue(InputEvent)) void {
    while (running) {
        if (poll(stdin, 1_ms)) |raw| {
            queue.push(.{
                .key = parseKey(raw),
                .timestamp = nanotime(),
            });
        }
    }
}

// メインループ: 固定タイムステップ
const FRAME_NS = 8_000_000;  // 8ms

fn mainLoop() void {
    while (running) {
        while (input_queue.pop()) |ev| processInput(ev);
        if (dirty) render();
        sleepUntilNextFrame();
    }
}
```

### Speculative Rendering

文字入力時の処理:
1. カーソル位置に文字を即座に描画（バッファ更新前）
2. ターミナルをフラッシュ
3. バッファ構造を更新
4. 次フレームで完全レンダリング（整合性確認）

---

## Rendering

### Double Buffer Cells

```zig
const Cell = struct {
    char: u21,
    fg: Color,
    bg: Color,
    attr: Attr,
};

const Screen = struct {
    front: []Cell,  // 現在表示中
    back: []Cell,   // 構築中

    fn flip(self: *@This()) void {
        // 差分を検出して変更されたセルのみ出力
        for (self.back, 0..) |cell, i| {
            if (cell != self.front[i]) {
                emitCell(i, cell);
            }
        }
        std.mem.swap([]Cell, &self.front, &self.back);
    }
};
```

### Output Batching

- すべてのエスケープシーケンスをバッファに蓄積
- フレームあたり1回の`write()`システムコール
- 相対カーソル移動を使用（バイト数最小化）

---

## Search Engine

### Literal Search: SIMD

```zig
fn simdSearch(haystack: []const u8, needle: u8) ?usize {
    const V = @Vector(32, u8);
    const target: V = @splat(needle);

    var i: usize = 0;
    while (i + 32 <= haystack.len) : (i += 32) {
        const chunk: V = haystack[i..][0..32].*;
        const mask = @as(u32, @bitCast(chunk == target));
        if (mask != 0) return i + @ctz(mask);
    }
    return null;
}
```

### Parallel Search

- バッファを1MBチャンクに分割
- スレッドプールに分配
- パターン長でチャンクをオーバーラップ（境界処理）
- 結果をマージ

### Incremental Search

- パターン拡張時に前回の結果をフィルタ
- 未検索領域を非同期で継続検索
- 表示を段階的に更新

---

## Shell Integration (C-;)

### 設計思想

- **zeは編集だけ、処理はUnixコマンドに任せる**
- **外部コマンドを最小キーストロークで呼べる**
- **パーサーは最小限、シェルに丸投げ**
- **組み込みコマンドは実装しない**（Unixコマンドで十分高速）

### 構文

```
[入力元] | コマンド [出力先]
```

`C-;` でプロンプト `|` が開き、コマンドを入力して Enter で実行。

### 入力元（プレフィックス）

| 記号 | 入力 |
|------|------|
| (なし) | 選択範囲（なければ stdin 空） |
| `%` | バッファ全体 |
| `.` | 現在行 |

### 出力先（サフィックス）

| 記号 | 出力 |
|------|------|
| (なし) | Command Buffer に表示（バッファ変更なし） |
| `>` | 入力元を置換 |
| `+>` | カーソル位置に挿入 |
| `n>` | 新規バッファ |

※ 末尾が `>` `+>` `n>` **単独**の場合のみzeの命令
※ `> /tmp/file` のように後続があればシェルのリダイレクト

### 実行モデル

1. 行頭のプレフィックス（`%` `.`）を取り出す → 入力元決定
2. 行末のサフィックス（`>` `+>` `n>`）を取り出す → 出力先決定
3. 残りを `sh -c "..."` に渡す
4. **別スレッドで実行**（UIブロックなし）
5. stdin に入力元を書いて close（EOF送信）
6. stdout を出力先に反映、stderr は Command Buffer に表示

### 実行中の動作

```
┌─────────────────────────────────────┐
│ バッファ                             │
├─────────────────────────────────────┤
│ | curl -X POST https://api.llm/...  │
├─────────────────────────────────────┤
│ [実行中... C-g でキャンセル]         │
└─────────────────────────────────────┘
```

- **タイムアウトなし**（LLM等の重い処理も待つ）
- **C-g でいつでもキャンセル**（子プロセスを kill）

### 使用例

```
| date +>                       # 日付をカーソル位置に挿入
| wc -l                         # 行数を Command Buffer に表示
% | wc -l                       # 全体の行数を表示
| sort >                        # 選択範囲をソートして置換
% | sort >                      # 全体をソートして置換
. | sh >                        # 現在行をシェル実行して置換
% | jq . >                      # 全体をJSON整形して置換
% | jq . | sed 's/a/b/g' >      # パイプラインも可
| grep TODO n>                  # 検索結果を新規バッファに
% | curl -X POST ... n>         # LLM呼び出し結果を新規バッファに
% | tee /tmp/out.json >         # ファイルにも出しつつバッファも置換
```

### サポート外

- **インタラクティブなコマンド**: `python`, `irb`, `node`
- **全画面TUI**: `vim`, `less`, `top`
- **入力を求めるコマンド**: `sudo`, `rm -i`

→ stdin は即座に close される（EOF送信）

---

## Internal Commands (M-x) - 将来実装予定

エディタ内部のコマンド。Shell Integration とは別系統。

| コマンド | 説明 |
|---------|------|
| `goto-line <n>` | n行目へ移動 |
| `set-tab-width <n>` | タブ幅設定 |
| `describe-key` | キーバインド確認 |
| `revert-buffer` | ファイルを再読み込み |

※ 現在はキーバインドで直接操作。M-x は将来実装予定。

---

## Keybindings (Emacs-like)

### Movement

| キー | 動作 |
|-----|--------|
| `C-f` | 前進（文字） |
| `C-b` | 後退（文字） |
| `C-n` | 次の行 |
| `C-p` | 前の行 |
| `C-a` | 行頭へ |
| `C-e` | 行末へ |
| `M-f` | 前進（単語） ※日本語対応：文字種別で移動 |
| `M-b` | 後退（単語） ※日本語対応：文字種別で移動 |
| `C-v` | ページダウン |
| `M-v` | ページアップ |
| `M-<` | バッファの先頭へ (beginning-of-buffer) ✅ |
| `M->` | バッファの末尾へ (end-of-buffer) ✅ |
| `M-{` | 前の段落へ (backward-paragraph) ✅ |
| `M-}` | 次の段落へ (forward-paragraph) ✅ |
| `C-l` | カーソルを中央に |

### Editing

| キー | 動作 |
|-----|--------|
| `C-d` | 文字削除 |
| `M-d` / `M-Del` | 単語削除 ※日本語対応：文字種別で削除 |
| `C-k` | 行末まで削除 |
| `C-Space` / `C-@` | マーク設定/解除 |
| `C-w` | 領域を削除（カット） |
| `M-w` | 領域をコピー |
| `C-y` | 貼り付け（ヤンク） |
| `C-u` | 元に戻す（Undo） |
| `C-/` | やり直す（Redo） |
| `M-^` | 行を上の行と結合 (join-line) ✅ |
| `M-↑` | 行を上に移動 ✅ |
| `M-↓` | 行を下に移動 ✅ |
| `Tab` | タブ挿入 / 選択範囲をインデント ✅ |
| `S-Tab` | アンインデント（左シフト） ✅ |
| `M-;` | コメント切り替え（# 挿入/削除） ✅ |

#### Rectangle (矩形選択)

| キー | 動作 |
|-----|--------|
| `C-x r k` | 矩形領域を削除（kill-rectangle） ✅ |
| `C-x r y` | 矩形を貼り付け（yank-rectangle） ✅ |

### File

| キー | 動作 |
|-----|--------|
| `C-x C-f` | ファイルを開く (find-file) ✅ |
| `C-x C-s` | 保存 |
| `C-x C-w` | 名前を付けて保存 |
| `C-x C-c` | 終了 |

### Buffer/Window

| キー | 動作 |
|-----|--------|
| `C-x b` | バッファ切り替え (switch-buffer) ✅ |
| `C-x C-b` | バッファ一覧表示 (list-buffers) ✅ |
| `C-x k` | バッファを閉じる (kill-buffer) ✅ |
| `C-x h` | 全選択 (mark-whole-buffer) ✅ |
| `C-x o` | 次のウィンドウに移動 (other-window) ✅ |
| `C-Tab` | 次のウィンドウに移動（高速切り替え） ✅ |
| `C-S-Tab` | 前のウィンドウに移動（高速切り替え） ✅ |
| `C-x 2` | 横分割 (split-window-below) ✅ |
| `C-x 3` | 縦分割 (split-window-right) ✅ |
| `C-x 0` | ウィンドウを閉じる (delete-window) ✅ |
| `C-x 1` | 他のウィンドウを閉じる (delete-other-windows) ✅ |

### Search

| キー | 動作 |
|-----|--------|
| `C-s` | インクリメンタル前方検索（ハイライト表示） |
| `C-r` | インクリメンタル後方検索（ハイライト表示） |
| `Enter` | 検索を確定 |
| `C-g` | 検索をキャンセル |
| `M-%` | Query Replace（対話的置換: y/n/!/q） ✅ |

### Command Line

| キー | 動作 |
|-----|--------|
| `M-x` | コマンドプロンプト（未実装） |
| `M-\|` | シェル統合: コマンド実行/領域をパイプ ✅ |

---



---

## File Structure

```
ze/
├── src/
│   ├── main.zig           # エントリポイント
│   ├── editor.zig         # エディタコア状態
│   ├── buffer.zig         # Piece table実装
│   ├── view.zig           # レンダリング、画面管理
│   ├── input.zig          # 入力処理、キーパース
│   ├── terminal.zig       # 端末制御
│   ├── encoding.zig       # エンコーディング検出・変換 ✨
│   ├── unicode.zig        # Unicode処理（grapheme cluster等）
│   └── config.zig         # 設定定数
│
│   # 将来追加予定:
│   # ├── command.zig        # コマンドパーサー、実行器
│   # ├── search.zig         # 検索エンジン (SIMD)
│   # ├── window.zig         # ウィンドウ/分割管理
│   # ├── keymap.zig         # キーバインディング定義
│   # ├── builtin.zig        # 組み込みコマンド
│   # ├── pipe.zig           # パイプライン実行
│   # └── util/
│   #     ├── arena.zig      # Arenaアロケータ
│   #     ├── btree.zig      # 索引用B-tree
│   #     ├── queue.zig      # ロックフリーキュー
│   #     └── simd.zig       # SIMDユーティリティ
├── build.zig
├── README.md
└── config/
    └── default.zig        # デフォルト設定、エイリアス
```

---

## Configuration

Zigによるコンパイル時設定:

```zig
// config.zig
pub const config = .{
    .tab_width = 4,
    .scroll_margin = 5,
    .frame_rate = 120,

    .colors = .{
        .fg = 0xFFFFFF,
        .bg = 0x1E1E1E,
        .cursor = 0x00FF00,
        .selection = 0x264F78,
    },

    .aliases = .{
        .{ "fmt", ". | zig fmt - > ." },
        // ...
    },

    .keymap_overrides = .{
        .{ "C-t", "transpose-chars" },
        // ...
    },
};
```

---

## Non-Goals

- LSP統合（v2で検討）
- プラグインシステム
- GUI
- Emacs Lisp互換性
- Org-mode
- Email、IRC、テトリス

---

## Inspirations

- **mg** — ミニマルなEmacs、クリーンなコードベース
- **kilo** — 1000行のエディタ、教育的
- **vis** — 構造的正規表現、sam/acmeのアイデア
- **kakoune** — 選択ファーストの編集
- **ripgrep** — 高速検索実装
- **Alacritty** — GPUアクセラレーテッド端末

---

## Implementation Roadmap

### 現在の状態 (v0.4-alpha) - 2024-12-07

**最新の更新: 複数ウィンドウ同時レンダリング＆シェル統合** ✨

#### v0.4の新機能 (2024-12-07)
- [x] **mmapゼロコピーファイル読み込み** ✨ **新規**
  - [x] UTF-8 + LF ファイルはmmap直接マッピング
  - [x] ファイルをメモリにコピーせず即座にオープン
  - [x] UTF-16やCRLF等は自動でフォールバックパスへ
  - [x] 1GBファイルも瞬時に読み込み可能

- [x] **マルチバッファ/マルチウィンドウアーキテクチャ**
  - [x] BufferStateとWindowの完全分離設計
  - [x] 複数バッファの同時管理
  - [x] ウィンドウごとに独立した表示状態
  - [x] バッファ/ウィンドウヘルパーメソッド群

- [x] **ファイル/バッファ操作コマンド**
  - [x] C-x C-f (find-file) - ファイルを開く、新規作成
  - [x] C-x b (switch-buffer) - バッファ切り替え
  - [x] C-x C-b (list-buffers) - バッファ一覧表示 ✨ **新規**
  - [x] C-x k (kill-buffer) - バッファを閉じる（安全性チェック）
  - [x] C-x o (other-window) - ウィンドウ切り替え
  - [x] バイナリファイル検出と自動拒否

- [x] **ウィンドウ分割** ✅ **完了 (Phase 4で実装済み)**
  - [x] C-x 2 (横分割) - 上下にウィンドウを分割
  - [x] C-x 3 (縦分割) - 左右にウィンドウを分割
  - [x] C-x 0 (ウィンドウを閉じる) - 現在のウィンドウを閉じる

- [x] **タブ文字処理の改善** ✨ **新規**
  - [x] タブ挿入時のカーソル位置を正しく計算
  - [x] C-f/C-b でタブ文字を正しく移動
  - [x] C-e (行末移動) でタブ幅を正しく計算
  - [x] タブ文字テストスイート (7テスト)

- [x] **包括的テストスイート** ✨ **新規**
  - [x] 複数バッファ/ウィンドウテスト (19テスト、6カテゴリ)
  - [x] タブ文字テスト (7テスト)

- [x] **複数ウィンドウの同時レンダリング** ✨ **新規**
  - [x] View.renderInBounds()でビューポート範囲内描画
  - [x] 各ウィンドウに独自のステータスバー表示
  - [x] アクティブウィンドウのみカーソル表示
  - [x] ウィンドウクローズ時のサイズ自動再計算

- [x] **シェル統合 (M-|)** ✨ **新規**
  - [x] バッファ/選択範囲をシェルコマンドにパイプ
  - [x] 入力元指定: 選択範囲(デフォルト) / % (全体) / . (現在行)
  - [x] 出力先指定: *Command*バッファ(デフォルト) / > (置換) / +> (挿入) / n> (新規バッファ)
  - [x] 非同期実行（UIブロックなし）
  - [x] C-gでキャンセル可能
  - [x] *Command*バッファが非表示の場合、自動でウィンドウ分割

- [x] **Query Replace (M-%)** ✨ **新規**
  - [x] 検索文字列→置換文字列の入力
  - [x] 対話的置換: y (置換) / n (スキップ) / ! (全置換) / q (終了)
  - [x] マッチのハイライト表示
  - [x] UTF-8/日本語対応

#### v0.1-v0.3の実装完了機能
- [x] **Piece tableバッファ実装**
  - [x] 効率的な挿入/削除（O(1)）
  - [x] Undo/Redo対応（C-u/C-/）
  - [x] ファイルI/O（保存: C-x C-s）
  - [x] Pieceマージ（隣接する同一ソースのPieceを自動結合）

- [x] **完全なUnicode/UTF-8対応** ✨
  - [x] Grapheme cluster境界認識（Unicode 15.0準拠）
  - [x] 絵文字完全サポート（ZWJ sequences、肌色修飾子、国旗）
  - [x] CJK文字対応（日中韓の全文字、幅2）
  - [x] 結合文字対応（Variation Selectors等）
  - [x] 10言語以上のスクリプト対応
  - [x] 62個の包括的テストで検証済み
  - [x] **差分描画時のUTF-8境界チェック**（文字化け防止）

- [x] **Emacsライクなキーバインド**
  - [x] 移動: C-n/p/f/b/a/e, M-f/b, 矢印キー
  - [x] 編集: C-d（文字削除）、M-d（単語削除）、C-k（行末まで削除）
  - [x] 範囲選択: C-Space/C-@（マーク設定）
  - [x] コピー&ペースト: C-w（カット）、M-w（コピー）、C-y（ペースト）
  - [x] 特殊: Enter（改行挿入）、C-h/Backspace（削除）、Tab
  - [x] Undo/Redo: C-u/C-/
  - [x] **検索: C-s（前方）、C-r（後方）、ハイライト表示**
  - [x] **終了: C-x C-c（未保存変更の警告付き）**
  - [x] Alt+大文字/数字/記号のサポート

- [x] **パフォーマンス最適化**
  - [x] O(1) バッファ長取得（total_len cache）
  - [x] **PieceIterator.seek()（O(pieces)直接ジャンプ）**
  - [x] LineIndex（O(log N)行アクセス）
  - [x] **deleteChar/backspace/backwardWordのO(n)問題修正**
  - [x] 差分描画（セルレベル、行ごと独立バッファ）
  - [x] 巨大行の最適化（画面幅で読み取り停止）
  - [x] インライン関数とコンパイル時最適化

- [x] **表示機能**
  - [x] **Tab文字の適切な処理**（タブ幅4で空白展開）
  - [x] **水平スクロール**（長い行の自動スクロール）
  - [x] ステータスバー（ファイル名、行番号、カラム、モード表示）

- [x] **入力処理**
  - [x] ESCシーケンス処理（100msタイムアウト）
  - [x] バイト分割到着対応

- [x] **テスト体制**
  - [x] 62個の包括的テスト（Unicode、カーソル移動、編集操作）
  - [x] すべてのテストが通過
  - [x] CI/CDレディ

### Phase 1: 実用最小限 (v0.2 - 優先度: 最高)
**目標: 実際にSSH先で使い始められるレベル**

- [x] **UTF-8完全対応** ✅ **完了**
  - [x] マルチバイト文字の正しい表示
  - [x] カーソル移動の文字境界認識
  - [x] 日本語・絵文字の編集
  - [x] 差分描画時の境界チェック
- [x] **Tab文字の適切な処理** ✅ **完了**
  - [x] タブ幅4で空白展開
  - [x] タブストップ位置の正確な計算
- [x] **水平スクロール** ✅ **完了**
  - [x] 長い行の自動スクロール
  - [x] カーソル移動時の自動調整
- [x] **保存確認機能** ✅ **完了**
  - [x] 未保存変更時の C-x C-c 警告
- [x] **インクリメンタル検索** ✅ **完了**
  - [x] 前方検索 (C-s)、後方検索 (C-r)
  - [x] マッチのハイライト表示（反転表示）
  - [x] C-s/C-rでの次/前マッチへの移動
  - [x] Enter確定、C-gキャンセル
- [x] **コピー/ペースト + killring** ✅ **完了**
  - [x] C-Space/C-@ (マーク設定/解除)
  - [x] C-k (kill-line)
  - [x] C-w (kill-region / カット)
  - [x] M-w (copy-region / コピー)
  - [x] C-y (yank / ペースト)
  - [ ] M-y (yank-pop) - 将来の拡張
- [x] **行番号表示** ✅ **完了**
- [x] **主要なバグ修正** ✅ **完了**
  - [x] O(n)パフォーマンス問題の修正
  - [x] Buffer境界チェック
  - [x] UTF-8境界チェック

### Phase 2: 安全性・エンコーディング・基本編集 (v0.2) ✅ **完了 (2024-12-05)**
**目標: SSH先で安心して使えるレベル**

#### 安全性機能
- [x] **アトミックセーブ** ✅
  - [x] 一時ファイルに書き出してから rename() で入れ替え
  - [x] 保存途中のクラッシュでもファイルが壊れない
- [x] **権限・パーミッション保持** ✅
  - [x] 元ファイルの mode を保持して保存
  - [x] 書き込み不可ファイルはステータスラインに [RO] 表示
- [x] **外部変更検知** ✅
  - [x] mtime チェックで外部変更を検出
  - [x] 保存時に「ファイルが外部で変更されています」警告
- [x] **バイナリファイル検出** ✅
  - [x] NULL バイト検出でバイナリファイルを拒否
  - [x] 誤って巨大バイナリを開いてフリーズを防ぐ
- [ ] **巨大ファイル警告**（未実装）
  - [ ] 一定サイズ以上（例: 100MB）で警告

#### 編集機能 ✅
- [x] **行操作** ✅ **完了**
  - [x] 行の結合（M-^）
  - [x] 行の移動（M-↑/M-↓）
- [x] **インデント操作** ✅ **完了**
  - [x] 範囲を右シフト（Tab）- スペース/タブ自動検出
  - [x] 範囲を左シフト（S-Tab）
- [x] **コメント切り替え** ✅ **完了**
  - [x] コメントアウト/アンコメント（M-;）
  - [x] デフォルトコメント文字: #

#### 検索機能
- [x] **検索履歴** ✅
  - [x] C-s で前回パターン再利用（次のマッチへ）
  - [x] C-r で前回パターン再利用（前のマッチへ）

#### ステータスライン拡張
- [x] **拡張ステータス情報** ✅
  - [x] [+] 変更フラグ / [RO] 読み取り専用フラグ
  - [x] 行番号 / カラム表示
  - [x] 改行コード表示（LF / CRLF / CR）
  - [x] エンコーディング表示（UTF-8 / UTF-8 BOM / UTF-16LE BOM / UTF-16BE BOM）

#### エンコーディング・改行コード対応
- [x] **エンコーディング検出と変換** ✅
  - [x] UTF-8, UTF-8 BOM, UTF-16LE BOM, UTF-16BE BOM の自動検出
  - [x] 読み込み時に UTF-8 へ変換・正規化
  - [x] 保存時に元のエンコーディングとBOMを復元
  - [x] Shift_JIS, EUC-JP の自動検出・変換
  - [x] encoding.zig モジュールの実装
- [x] **改行コード対応** ✅
  - [x] LF/CRLF/CR の自動検出
  - [x] 読み込み時に LF に正規化
  - [x] 保存時に元の改行コードで出力
  - [x] 内部表現は常に UTF-8 + LF
  - [x] ステータスラインに表示

#### エラーハンドリング
- [x] **エラーメッセージ表示** ✅
  - [x] ステータスバーで表示
  - [x] 外部変更、削除の警告表示

### Phase 3: 端末環境・見た目 (v0.3) - ✅ 一部完了
**目標: 端末で快適に動作**

- [x] **端末互換性** ✅ **完了**
  - [x] TERM が妙な値（screen-256color 等）でも動作
  - [x] 色が崩れても操作はできる設計（基本的なANSI色のみ使用）
- [x] **リサイズ対応**（SIGWINCH） ✅ **完了**
  - [x] SIGWINCHシグナルハンドラで即座に検出
  - [x] 即座に再描画
  - [x] 行番号・ステータスライン常に正しく
- [x] **コメント行の色変更** ✅ **完了**
  - [x] シンタックスハイライトよりライト（グレー表示）
  - [x] 行頭 # / // / ; / -- を自動検出
  - [x] インデント付きコメントも対応
- [ ] **.editorconfig 対応**
  - [ ] tab_width や indent_style を反映
- [ ] **簡易正規表現検索**
  - [ ] . * [] ^ $ \d くらいのライトなもの

### Phase 4: 複数バッファと置換 (v0.4) - ✅ 完了
**目標: 日常的に使えるレベル**

- [x] **置換機能** (M-%) ✅ **完了**
  - [x] 検索・置換の問い合わせ (y/n/!/q)
  - [x] 一括置換 (! キー)
- [x] **複数バッファ** ✅ **基本機能完了 (2024-12-07)**
  - [x] マルチバッファ/マルチウィンドウアーキテクチャ実装
  - [x] BufferState/Window分離設計
  - [x] C-x C-f (find-file) - 新規ファイル作成、既存ファイルオープン
  - [x] C-x b (switch-buffer) - バッファ切り替え
  - [x] C-x k (kill-buffer) - バッファを閉じる（安全性チェック付き）
  - [x] バイナリファイル検出（C-x C-fで自動拒否）
  - [x] バッファリスト表示 (C-x C-b)
- [x] **自動インデント** ✅ **完了**
  - [x] 基本的なインデント継承（Enter時に前の行のインデントを継承）
  - [x] Tab/Spaceの自動判定（ドキュメント内のインデントスタイルを検出）

### Phase 5: モダンな見た目 (v0.5)
**目標: 綺麗で快適なUI**

- [ ] **シンタックスハイライト** (シンプルな正規表現ベース)
  - [ ] 主要言語5-10個 (Zig, C, Go, Python, JS, Rust等)
  - [ ] ファイル拡張子による自動認識
- [ ] **24bit色対応**
  - [ ] シンタックスハイライトでの利用
  - [ ] デフォルトテーマ (Dracula風、Nord風等)
- [ ] **大きなファイルの最適化**
  - [ ] 遅延ロード
  - [ ] 1GB以上のファイル対応

### Phase 6: Unix統合 (v0.6) - 🚧 一部完了
**目標: Unixツールとの連携**

- [x] **シェル統合 (M-|)** ✅ **完了**
  - [x] M-| リージョン/バッファをパイプ
  - [x] 入力元: 選択範囲 / % (全体) / . (現在行)
  - [x] 出力先: *Command*バッファ / > (置換) / +> (挿入) / n> (新規)
  - [x] 非同期実行、C-gでキャンセル
  - [x] *Command*バッファ自動表示（ウィンドウ分割）
- [ ] **コマンドライン (ミニバッファ)**
  - [ ] M-x コマンド入力
  
### Phase 7: 高度な機能 (v1.0) - 🚧 一部完了
**目標: パワーユーザー向け**

- [x] **複数バッファ管理** ✅ **完了 (Phase 4で実装済み)**
  - [x] C-x b (switch-buffer)
  - [x] C-x k (kill-buffer)
  - [x] C-x C-b (バッファ一覧) ✅
- [x] **ウィンドウ分割** ✅ **完了 (Phase 4で実装済み)**
  - [x] マルチウィンドウアーキテクチャ実装 (BufferState/Window分離)
  - [x] C-x 2 (横分割) - 上下にウィンドウを分割
  - [x] C-x 3 (縦分割) - 左右にウィンドウを分割
  - [x] C-x 0 (ウィンドウを閉じる) - 現在のウィンドウを閉じる
  - [x] C-x 1 (他のウィンドウを閉じる) ✅
  - [x] C-x o (ウィンドウ切り替え) ✅ 実装済み
- [ ] **拡張マーク機能**
  - [ ] C-x C-x (exchange-point-and-mark)
- [ ] **レジスタ**
  - [ ] テキストの保存・呼び出し
- [ ] **差分ログベースのUndo/Redo**
  - [ ] メモリ効率の改善
- [ ] **mmap ファイルロード**

### Phase 8: 便利機能 (v1.1)

- [ ] **ヘルプ機能**
  - [ ] C-h ? でキーバインド一覧
  - [ ] ze --help / ze --version
- [ ] **キーボードマクロ**
  - [ ] C-x ( 記録開始
  - [ ] C-x ) 記録終了
  - [ ] C-x e 実行
- [ ] **マウスサポート (オプション)**
  - [ ] クリックでカーソル移動
  - [ ] ドラッグで選択

### 長期目標 (v2.0+)
- [x] **レガシーエンコーディング変換** ✅ **完了**
  - [x] Shift_JIS → UTF-8 変換実装
  - [x] EUC-JP → UTF-8 変換実装
  - [x] ヒューリスティック検出による自動判別
- [ ] LSP対応 (オプション、軽量に)
- [ ] 設定ファイルサポート (Zig製でコンパイル時評価)
- [ ] プラグインシステム (シンプルなもの)
- [ ] パイプ構文 (Unix統合の拡張)

---

## 現在の技術的負債

### 最優先で対処が必要
1. ~~**UTF-8非対応**~~ ✅ **完了**: Grapheme cluster境界認識、絵文字・CJK完全対応
2. ~~**カーソル位置の不正確さ**~~ ✅ **完了**: grapheme cluster単位の正確なカーソル移動実装
3. **エラーハンドリング**: `try`で即終了、ユーザーにメッセージなし（未対応）

### Phase 2で対処
4. ~~**Undo/Redoのメモリ効率**~~ ✅ **完了**: 連続insert結合 + 1000エントリ上限実装
5. **ファイルロード**: readToEndAllocではなくmmap（未対応）
6. ~~**完全な差分描画**~~ ✅ **完了**: LineIndex + dirty範囲トラッキング実装

### v0.1で完了した最適化 (2024-12-04)
- ✅ **LineIndex導入**: O(1)行アクセス（O(file_size)描画を解決）
- ✅ **PieceIterator.seek()**: O(pieces)直接ジャンプ
- ✅ **errdefer rollback**: 編集操作の原子性保証
- ✅ **メモリ最適化**: 再利用バッファで描画時のヒープ確保削減
- ✅ **dirty範囲の正確な管理**: ?usizeでEOF表現、maxInt wrap回避

---

## License

MIT または BSD-2-Clause（未定）

---

*"一つのことを上手く行う。高速に。"*

## Testing

zeは汎用PTYテストハーネスを提供しており、自動テストが可能です。

### 汎用テストハーネス

`test_harness_generic.zig` を使って、キーシーケンスを指定してzeをテストできます。

```bash
# 新規ファイル作成テスト
zig run test_harness_generic.zig -lc -- "hello" "C-x" "C-s" "/tmp/test.txt" "Enter" "C-x" "C-c"

# 既存ファイル編集テスト
zig run test_harness_generic.zig -lc -- --file=README.md "C-e" " world" "C-x" "C-s" "C-x" "C-c"
```

**特殊キー**:
- `C-<char>`: Ctrl+文字 (例: `C-x`, `C-s`, `C-g`)
- `M-<char>`: Alt+文字 (例: `M-f`, `M-b`)  
- `Enter`, `Backspace`, `Tab`, `Escape`
- `Up`, `Down`, `Left`, `Right`

**オプション**:
- `--file=<path>`: 指定ファイルを開く
- `--wait=<ms>`: キー送信前の待機時間(デフォルト: 500ms)
- `--delay=<ms>`: キー間の遅延(デフォルト: 100ms)
- `--show-output`: zeの出力を表示

### テストデータ

テストファイルは`test_data/`ディレクトリに永続化されています:

```bash
# テストデータのセットアップ (初回のみ)
cd test_data && ./setup_test_files.sh

# 統合テストスイート実行 (106テスト、22カテゴリ)
./run_all_tests.sh

# タブ文字テスト (7テスト)
./test_data/test_tab.sh

# 複数バッファ/ウィンドウテスト (19テスト、6カテゴリ)
./test_data/test_multi_buffer.sh
```

**テストカバレッジ**:
- カテゴリ 1-10: 基本機能 (編集、カーソル、ファイル、検索、日本語、絵文字、長い行、大量行、スクロール、エッジケース)
- カテゴリ 11-22: 高度な機能 (Undo/Redo、範囲選択、単語操作、Emacs移動、削除、後方検索、複合操作、UTF-8、ファイル詳細、ストレステスト、Query Replace、検索履歴)
- タブ文字テスト: 入力、カーソル移動、削除 (7テスト)
- 複数バッファ/ウィンドウテスト: バッファ操作、ウィンドウ分割、同一/異なるバッファ編集、基本操作、エッジケース (19テスト)
- 合計132個の包括的テスト
- 日本語・絵文字・UTF-8完全対応テスト含む

