# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

**ze** (Zig Editor / Zero-latency Editor) は、mgとUnix哲学に影響を受けた、高速で最小限のテキストエディタです。Zigで実装され、Emacsキーバインディングとシェル統合を特徴とします。

### プロジェクトの核心：速度への執着

このプロジェクトの最優先事項は**速度**です：

- **他製品より速く**: Vim、Helix、Kilo等の既存エディタと比較して、起動・レスポンス・操作感すべてで勝つ
- **小気味良い動作**: ユーザーが「速い！」と体感できるレベルの高速性
- **しがらみのない革新**: 既存実装にとらわれず、理論的に最速の方法を追求
- **ガンガン最適化**: 速度のためなら大胆なリファクタリングも躊躇しない

速度は機能ではなく、このエディタの**存在意義**です。

### zeの位置づけ：VSCodeのアンチテーゼ

zeは「重くなったVSCode」への回答です：

- **単純なテキストエディタ**: IDEではない、軽量な編集ツール
- **Unix編集作業**: サーバーの設定ファイル、ちょっとしたコード修正
- **拡張性は持たせない**: プラグインシステム、LSP統合、拡張機能は実装しない
- **シンプルに保つ**: 「ちょっとサーバーの編集するか」でサクッと起動・編集

**典型的なユースケース**:
```bash
ssh server
ze /etc/nginx/nginx.conf    # 設定をサクッと編集
ze script.sh                 # シェルスクリプトをちょこっと修正
```

Vim/Emacsのような「全部入り環境」を目指さない。zeは**Unix的な道具の1つ**。

## 開発状態

現在は設計・初期実装フェーズ（Phase 1）です。README.mdに詳細な設計書があります。

**重要**: このプロジェクトは未リリースの開発初期段階です。以下の方針で開発してください：

- **破壊的変更OK**: 後方互換性は一切考慮不要です
- **大胆なリファクタリング歓迎**: より良い設計があれば躊躇なく全面的に書き直してください
- **パフォーマンス優先**: 正しさとパフォーマンスのためなら、既存コードを完全に捨てて構いません
- **API変更自由**: 関数シグネチャ、構造体レイアウト、全て自由に変更可能です

## ビルドとテスト

```bash
# ビルド
zig build

# リリースビルド（最適化）
zig build -Doptimize=ReleaseFast

# ユニットテスト実行
zig build test

# 実行
./zig-out/bin/ze [file]

# 統合テストスイート
./run_all_tests.sh
```

### 統合テストスイート

すべての機能を網羅する自動テストスイート (106テスト、22カテゴリ):

```bash
# 全テスト実行 (約1-2分)
./run_all_tests.sh

# テストデータのセットアップ (初回のみ)
cd test_data && ./setup_test_files.sh
```

**テストカテゴリ**:
1. 基本的な編集操作 (4テスト)
2. カーソル移動 (6テスト)
3. ファイル操作 (3テスト)
4. 検索機能 (3テスト)
5. 日本語対応 (4テスト)
6. 絵文字対応 (3テスト)
7. 長い行の処理 (3テスト)
8. 大量行の処理 (3テスト)
9. ページスクロール (3テスト)
10. エッジケース (4テスト)
11. Undo/Redo機能 (6テスト)
12. 範囲選択とコピー/カット/ペースト (6テスト)
13. 単語移動と削除 (6テスト)
14. Emacsスタイルカーソル移動 (6テスト)
15. 削除操作 (6テスト)
16. 後方検索 (4テスト)
17. 複合操作とエッジケース (6テスト)
18. 日本語とUTF-8詳細テスト (6テスト)
19. ファイル操作詳細 (5テスト)
20. ストレステストと境界値 (6テスト)
21. Query Replace (M-%) (9テスト)
22. 検索履歴 (4テスト)

### PTYテストハーネス（自動E2Eテスト）

`test_harness_generic.zig`を使用して、実際のzeを擬似TTY上で起動してテストできます：

```bash
# 基本的な使い方：キーシーケンスを引数として渡す
zig run test_harness_generic.zig -lc -- "hello" "C-x" "C-s" "/tmp/test.txt" "Enter" "C-x" "C-c"

# 既存ファイルを開いて編集
zig run test_harness_generic.zig -lc -- --file=/tmp/existing.txt "C-e" " world" "C-x" "C-s" "C-x" "C-c"

# タイミング調整（待機500ms、キー間遅延100ms）
zig run test_harness_generic.zig -lc -- --wait=500 --delay=100 "hello" "Enter"

# ze の出力を表示（デバッグ時に有用）
zig run test_harness_generic.zig -lc -- --show-output "test" "C-x" "C-c"
```

**重要：ハーネスが動かない場合はハーネス自体も修正すること**

機能の実装やバグ修正時、ハーネスでテストして問題が見つかった場合：
1. **まずzeのコードを修正**
2. **ハーネスでテストが通らない場合、ハーネス自体も修正**
3. 両方が正しく動作することを確認してから完了とする

ハーネスの問題例と修正例：
- タイムアウトしてハング → タイムアウト処理と強制終了を追加
- クラッシュを検出できない → 出力をパースしてクラッシュを検出
- 特定のキーシーケンスが送れない → parseKeySequenceを拡張

**方針**: ハーネスは「動作確認の自動化」が目的。ハーネスが使えなければ手動テストに戻ってしまう。ハーネスを常に改善し続けること。

### テストのトラブルシューティング

**重要: テストが失敗したら、まず本体のバグを疑え**

テストがタイムアウトしたり失敗した場合、「テストハーネスの問題」と決めつけずに、**まずze本体のバグを疑ってください**。

#### デバッグ手順

1. **`--show-output`で出力を確認**
   ```bash
   zig run test_harness_generic.zig -lc -- --show-output --file=test.txt "M-%" "hello" "Enter" "world" "Enter" "!" "C-x" "C-c" "n"
   ```
   - 何が画面に表示されているか確認
   - 入力した文字が表示されているか？
   - エラーメッセージが出ていないか？

2. **手動で同じ操作を試す**
   ```bash
   ./zig-out/bin/ze test.txt
   # テストと同じキーシーケンスを手動で入力
   ```
   - 手動でも同じ問題が起きるか確認
   - 手動で動作するならハーネスの問題
   - 手動でも失敗するなら本体のバグ

3. **根本原因を調査**
   - タイムアウト = 何かの入力待ちでハング → 本体のバグの可能性大
   - クラッシュ = 明らかに本体のバグ
   - 予期しない動作 = 本体のロジックバグ

#### 実例：日本語置換テストのケース

**症状**: テスト21.10（日本語置換）がタイムアウト
**初期の誤判断**: 「日本語をハーネスで渡すのが困難」→ スキップ
**実際の原因**: Query Replaceモードで`.codepoint`キーを処理していなかった（本体のバグ）

**正しいアプローチ**:
1. `--show-output`で確認 → 日本語が表示されていない
2. 手動テスト → 同じ問題を確認
3. コード調査 → `src/editor.zig`で`.char`のみ処理、`.codepoint`が未処理
4. 修正 → `.codepoint`ケースを追加
5. 解決 → テストが通るようになった

**教訓**: 「できない」と諦める前に、**なぜできないのか**を徹底的に調査すること。

#### よくある問題と対処法

| 症状 | 原因の可能性 | 確認方法 |
|------|------------|---------|
| タイムアウト | 入力待ちでハング | `--show-output`で最後の状態を確認 |
| 予期しない終了 | モード処理のバグ | 手動で同じ操作を試す |
| 文字が表示されない | UTF-8処理のバグ | エスケープシーケンスを確認 |
| キーが効かない | キーバインドの未実装 | `src/editor.zig`を確認 |

#### テストハーネスの改善

本体のバグでないことが確認できたら、ハーネス自体を改善：
- `--input-file`オプションでファイルからキーシーケンス読み込み（シェルクォート問題の回避）
- タイムアウト時間の調整（`--wait`, `--delay`オプション）
- 新しいキータイプのサポート追加（`parseKeySequence()`を拡張）

**重要：新規キーバインドを追加したら必ずハーネスにも追加すること**

zeに新しいキーバインド（例：C-/、M-delete等）を実装したら、**必ず同時に** `test_harness_generic.zig` の `parseKeySequence()` 関数にそのキーのサポートを追加してください。

これを守らないと：
- ❌ 統合テストでその機能をテストできない
- ❌ リグレッションを見逃す可能性がある
- ❌ 後で気づいて慌てて追加することになる

**手順**：
1. zeのeditor.zigに新しいキーバインドを追加
2. test_harness_generic.zigの`parseKeySequence()`にそのキーのパース処理を追加
3. 両方を同じコミットに含める

**例**：C-/（Redo）を追加する場合
```zig
// test_harness_generic.zig
else if (char == '/' or char == '_')
    31 // C-/ と C-_ は 0x1f (31)
```

**特殊キーの指定方法**：
- `C-<char>`: Ctrl+文字（例: `C-x`, `C-s`, `C-g`, `C-/`, `C-@`）
- `M-<char>`: Alt+文字（例: `M-f`, `M-b`, `M-w`, `M-delete`）
- `C-Space`: Ctrl+Space（マーク設定）
- `Enter`, `Backspace`, `Tab`, `Escape`: 各特殊キー
- `Up`, `Down`, `Left`, `Right`, `Home`, `End`: 矢印キー、ナビゲーション
- 通常文字列: そのまま入力（例: `"hello world"`）

**オプション**：
- `--file=<path>`: 指定したファイルを開いて起動
- `--wait=<ms>`: 起動後のキー送信前待機時間（デフォルト: 500ms）
- `--delay=<ms>`: キー間の遅延（デフォルト: 100ms）
- `--show-output`: zeの出力を表示

**テストハーネスの仕組み**：
- POSIXの`openpty()`で擬似TTYを作成
- `fork()`で子プロセスとしてzeを起動
- コマンドライン引数で指定されたキーシーケンスを送信
- クラッシュやエラーを検出

**利点**：
- コマンドライン引数で柔軟にテストシナリオを指定可能
- ハーネス本体を編集せずに多様なテストが可能
- 手動テストが不要（自動化）
- TTYが必要なコードを確実にテスト
- CI/CDで実行可能
- クラッシュの再現と修正確認が容易

**実用例**：

```bash
# 新規ファイル作成と保存のテスト
zig run test_harness_generic.zig -lc -- "line 1" "Enter" "line 2" "C-x" "C-s" "/tmp/test.txt" "Enter" "C-x" "C-c"

# 編集とキャンセルのテスト（C-gでキャンセル）
zig run test_harness_generic.zig -lc -- "test" "C-x" "C-g"

# ファイル名入力のバックスペーステスト
zig run test_harness_generic.zig -lc -- "text" "C-x" "C-s" "/tmp/wrong" "Backspace" "Backspace" "Backspace" "Backspace" "Backspace" "right.txt" "Enter" "C-x" "C-c"
```

## アーキテクチャの要点

### コアデータ構造

1. **Buffer (buffer.zig)**: Piece Table + B-tree
   - 元ファイルはmmap（読み取り専用、ゼロコピー）
   - 追加バッファはArenaアロケータ（フラグメンテーションなし）
   - B-treeで行番号→pieceオフセットの索引（遅延、オンデマンド）

2. **View (view.zig)**: ダブルバッファセル、差分のみレンダリング
   - フロント/バックバッファを使用
   - 変更されたセルのみ出力（差分レンダリング）
   - 1フレームあたり1回のwrite()システムコール

3. **Input (input.zig)**: 専用入力スレッド
   - epoll/kqueue使用
   - ロックフリーキューでメインスレッドと通信
   - 投機的レンダリング：文字入力時に即座に描画してからバッファ更新

4. **Search (search.zig)**: SIMD検索エンジン
   - リテラル検索にSIMD命令使用
   - 1MBチャンクに分割して並列検索
   - インクリメンタル検索対応

### パフォーマンス目標（競合製品を超える）

| 指標 | 目標値 | 競合参考値 |
|------|--------|-----------|
| 起動時間 | < 10ms | Vim: 50-100ms, Helix: 30ms |
| キー入力から画面更新 | < 8ms (125fps) | Vim: 16ms, Helix: 10ms |
| ファイルオープン (1GB) | < 100ms | Vim: 500ms+ |
| 検索速度 (1GB) | > 2GB/s | ripgrep: 2-3GB/s |
| メモリオーバーヘッド | ファイルサイズの約10% | Vim: 50-100% |

**測定方針**:
- 定期的にベンチマークを取る
- 競合製品と比較して退化を許さない
- 体感速度を最重視（数値だけでなく「気持ち良さ」）

## Shell Integration (C-;)

外部コマンドとの連携。zeは編集だけ、処理はUnixコマンドに任せる。

### 構文

```
[入力元] | コマンド [出力先]
```

### 入力元（プレフィックス）

- (なし): 選択範囲（なければ stdin 空）
- `%`: バッファ全体
- `.`: 現在行

### 出力先（サフィックス）

- (なし): Command Buffer に表示
- `>`: 入力元を置換
- `+>`: カーソル位置に挿入
- `n>`: 新規バッファ

### 例

```
| sort >              # 選択範囲をソートして置換
% | sort >            # 全体をソートして置換
. | sh >              # 現在行をシェル実行して置換
% | jq . >            # JSON整形
% | jq . | sed 's/a/b/' >  # パイプラインも可
| grep TODO n>        # 検索結果を新規バッファに
```

### 実行モデル

- コマンド部分は `sh -c "..."` に丸投げ
- 別スレッドで非同期実行（UIブロックなし）
- C-g でキャンセル可能
- タイムアウトなし（LLM呼び出し等も待つ）

## 実装の優先順位

Phase 1（現在）では以下を実装：
- Piece tableバッファ
- 基本レンダリング
- Emacs移動キー（C-f, C-b, C-n, C-p, C-a, C-e等）
- 挿入/削除
- ファイルI/O

## コーディングガイドライン

### 基本原則

- **パフォーマンス最優先**: 8ms以内の応答性を維持
- **ゼロコピー**: 可能な限りmmapとスライスを使用
- **comptime活用**: キーマップテーブル等はコンパイル時に解決
- **アロケーション最小化**: Arena/固定バッファ使用
- **SIMD最適化**: 検索等の高速化にSIMD命令を活用
- **シンプルさ**: Unix哲学に従い、1つのことを上手く行う

### 「あるべき姿」の追求

このプロジェクトでは、機能の理論的に最適な実装（「あるべき姿」）を追求します：

- **最適化の妥協を避ける**: 「十分速い」ではなく「理論的に最速」を目指す
- **段階的な改善**: まず動くものを作り、次に最適化する（premature optimizationは避ける）
- **複雑さとのバランス**: ただし以下の場合は「あるべき姿」を諦める
  - コードが極端に複雑になる（理解困難、保守困難）
  - コード量が2倍以上になる
  - 実測で効果が10%未満

#### 実装例：セルレベル差分描画

「行単位の差分描画」から「セルレベル差分描画」への改善：
- 前フレームの画面状態を保持（メモリコスト: 数KB）
- バイト単位で差分検出して変更部分のみ描画
- **効果**: ターミナル出力量40-90%削減、体感できる速度向上
- **複雑さ**: 許容範囲（約100行の追加、ロジックは明快）
- **結論**: 実装すべき ✅

このように、効果が明確で複雑さが許容範囲なら、積極的に「あるべき姿」を実装してください。

### さらなる最適化の方向性

常に速度向上の機会を探してください：

#### 起動時間の短縮
- **遅延初期化**: 使われるまで初期化しない
- **comptime計算**: キーマップ等をコンパイル時に解決
- **静的リンク**: 動的ライブラリ読み込みを回避

#### レンダリングの高速化
- ✅ セルレベル差分描画（実装済み）
- **ダブルバッファリング**: フロント/バックバッファで描画と表示を分離
- **バッチ書き込み**: 複数の変更を1回のwrite()にまとめる
- **ANSI最適化**: エスケープシーケンスを最短に

#### 入力処理の最適化
- **投機的レンダリング**: キー入力を先読みして即座に描画
- **キーリピート検出**: 連続入力時の最適化パス
- **専用入力スレッド**: ブロッキングI/Oを別スレッドで

#### メモリ最適化
- **Arena allocator**: 細かいアロケーションを一括管理
- **固定バッファ**: 頻繁に使うバッファは事前確保
- **mmap活用**: 大きなファイルはゼロコピー

#### プロファイリングの習慣
```bash
# 定期的にプロファイル
hyperfine --warmup 3 './zig-out/bin/ze test.txt'
perf record ./zig-out/bin/ze test.txt
```

「ここはもっと速くできるはず」と常に疑ってください。

## ファイル構造

```
ze/
├── src/
│   ├── main.zig          # エントリポイント
│   ├── editor.zig        # エディタコア状態
│   ├── buffer.zig        # Piece table実装
│   ├── view.zig          # レンダリング、画面管理
│   ├── input.zig         # 入力処理、キーパース
│   ├── command.zig       # コマンドパーサー、実行器
│   ├── search.zig        # 検索エンジン (SIMD)
│   ├── terminal.zig      # 端末制御
│   ├── window.zig        # ウィンドウ/分割管理
│   ├── keymap.zig        # キーバインディング定義
│   ├── builtin.zig       # 組み込みコマンド
│   ├── pipe.zig          # パイプライン実行
│   └── util/
│       ├── arena.zig     # Arenaアロケータ
│       ├── btree.zig     # B-tree索引
│       ├── queue.zig     # ロックフリーキュー
│       └── simd.zig      # SIMDユーティリティ
├── build.zig
├── README.md
└── config/
    └── default.zig       # デフォルト設定、エイリアス
```

## 非目標（絶対に実装しない）

以下の機能は**永久に実装しません**。機能追加の誘惑に負けないこと：

### IDE的機能（実装禁止）
- ❌ シンタックスハイライト：色付けは不要、テキストはテキスト
- ❌ LSP統合：補完、定義ジャンプ等は別のツールで
- ❌ デバッガ統合：gdb/lldbを使え
- ❌ ビルドシステム：makeやビルドツールを直接使え
- ❌ プロジェクト管理：ファイルはファイル、管理は不要

### 拡張性（実装禁止）
- ❌ プラグインシステム：拡張できない = シンプルに保てる
- ❌ スクリプト言語埋め込み：Lua、JavaScript等は不要
- ❌ 外部モジュール読み込み：動的ロード、プラグインAPI等は不要

### UI的機能（実装禁止）
- ❌ マウスサポート：キーボードのみ、マウスは邪魔
- ❌ GUI：ターミナルのみ、GUIは別のツールで
- ❌ ファイルツリー：lsやfzfを使え
- ❌ タブ表示：複数ファイルはtmux/screen分割で

### 「便利」機能（実装禁止）
- ❌ Git統合：gitコマンドを直接使え
- ❌ ターミナルエミュレータ内蔵：tmuxがある
- ❌ マクロシステム：シェルスクリプトを書け
- ❌ AI補完：Copilot等は別のツールで

**方針**: 「これあると便利かも」は全て却下。zeは**編集だけ**。

## 設定ファイルの方針

設定ファイルは**最小限**で許可します：

### デフォルトのキーバインド：Emacs-like

**デフォルトはEmacs風キーバインド**。理由：

- **モードレス**: モード切り替えが不要、シンプル
- **直感的**: C-f（前進）、C-b（後退）、C-n（次行）、C-p（前行）
- **実装がシンプル**: Vimのような複雑なモード管理が不要
- **市場の空白**: 軽くてモダンなEmacs風エディタは少ない

Vimモードは実装しない：
- モードが多すぎる（Normal/Insert/Visual/Command...）
- コマンドが膨大（実装・保守が複雑化）
- Vimユーザーは既にVim/Neovimを使っている

### 許可する設定
- ✅ **キーバインディング**: 個別キーの割り当て変更（Emacs風の範囲内）
- ✅ **基本動作**: タブ幅、インデント、改行コード
- ✅ **表示**: 行番号表示、カーソル形状
- ✅ **色**: ステータスバー、カーソル行ハイライト（最小限）

### 禁止する設定
- ❌ **拡張機能**: プラグイン、外部スクリプト実行
- ❌ **言語別設定**: 言語ごとの細かい挙動変更
- ❌ **複雑な条件**: if文だらけの設定ロジック
- ❌ **UI要素**: ツールバー、サイドバー（そもそも存在しない）

### 設計原則
```
デフォルトで十分。設定は「念のため」。
```

- **デフォルトで一般的な使い方ができる**: 設定なしでも満足できる
- **設定項目は10-20個以内**: アホみたいに増やさない
- **設定ファイルは1つ**: `~/.config/ze/config` のみ
- **シンプルな形式**: JSON/TOML等、人間が読み書きしやすい

**目標**: 「設定見なくても使える。でも必要なら変えられる。」
