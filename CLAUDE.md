# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

**ze** (Zig Editor / Zero-latency Editor) は、mgとUnix哲学に影響を受けた、高速で最小限のテキストエディタです。Zigで実装され、Emacsキーバインディングとシェル統合を特徴とします。

### プロジェクトの核心：速度への執着

このプロジェクトの最優先事項は**速度**です：

- **他製品より速く**: Vim、Helix、Kilo等の既存エディタと比較して、起動・レスポンス・操作感すべてで勝つ
- **小気味良い動作**: ユーザーが「速い！」と体感できるレベルの高速性
- **しがらみのない革新**: 既存実装にとらわれず、理論的に最速の方法を追求
- **ガンガン最適化**: 速度のためなら大胆なリファクタリングも躊躇しない

速度は機能ではなく、このエディタの**存在意義**です。

### zeの位置づけ：VSCodeのアンチテーゼ

zeは「重くなったVSCode」への回答です：

- **単純なテキストエディタ**: IDEではない、軽量な編集ツール
- **Unix編集作業**: サーバーの設定ファイル、ちょっとしたコード修正
- **拡張性は持たせない**: プラグインシステム、LSP統合、拡張機能は実装しない
- **シンプルに保つ**: 「ちょっとサーバーの編集するか」でサクッと起動・編集

**典型的なユースケース**:
```bash
ssh server
ze /etc/nginx/nginx.conf    # 設定をサクッと編集
ze script.sh                 # シェルスクリプトをちょこっと修正
```

Vim/Emacsのような「全部入り環境」を目指さない。zeは**Unix的な道具の1つ**。

## 開発状態

現在は設計・初期実装フェーズ（Phase 1）です。README.mdに詳細な設計書があります。

**重要**: このプロジェクトは未リリースの開発初期段階です。以下の方針で開発してください：

- **破壊的変更OK**: 後方互換性は一切考慮不要です
- **大胆なリファクタリング歓迎**: より良い設計があれば躊躇なく全面的に書き直してください
- **パフォーマンス優先**: 正しさとパフォーマンスのためなら、既存コードを完全に捨てて構いません
- **API変更自由**: 関数シグネチャ、構造体レイアウト、全て自由に変更可能です

## ビルドとテスト

```bash
# ビルド
zig build

# リリースビルド（最適化）
zig build -Doptimize=ReleaseFast

# ユニットテスト実行
zig build test

# 実行
./zig-out/bin/ze [file]
```

### PTYテストハーネス（自動E2Eテスト）

`test_harness_generic.zig`を使用して、実際のzeを擬似TTY上で起動してテストできます：

```bash
# 基本的な使い方：キーシーケンスを引数として渡す
zig run test_harness_generic.zig -lc -- "hello" "C-x" "C-s" "/tmp/test.txt" "Enter" "C-x" "C-c"

# 既存ファイルを開いて編集
zig run test_harness_generic.zig -lc -- --file=/tmp/existing.txt "C-e" " world" "C-x" "C-s" "C-x" "C-c"

# タイミング調整（待機500ms、キー間遅延100ms）
zig run test_harness_generic.zig -lc -- --wait=500 --delay=100 "hello" "Enter"

# ze の出力を表示
zig run test_harness_generic.zig -lc -- --show-output "test" "C-x" "C-c"
```

**特殊キーの指定方法**：
- `C-<char>`: Ctrl+文字（例: `C-x`, `C-s`, `C-g`）
- `M-<char>`: Alt+文字（例: `M-f`, `M-b`）
- `Enter`, `Backspace`, `Tab`, `Escape`: 各特殊キー
- `Up`, `Down`, `Left`, `Right`: 矢印キー
- 通常文字列: そのまま入力（例: `"hello world"`）

**オプション**：
- `--file=<path>`: 指定したファイルを開いて起動
- `--wait=<ms>`: 起動後のキー送信前待機時間（デフォルト: 500ms）
- `--delay=<ms>`: キー間の遅延（デフォルト: 100ms）
- `--show-output`: zeの出力を表示

**テストハーネスの仕組み**：
- POSIXの`openpty()`で擬似TTYを作成
- `fork()`で子プロセスとしてzeを起動
- コマンドライン引数で指定されたキーシーケンスを送信
- クラッシュやエラーを検出

**利点**：
- コマンドライン引数で柔軟にテストシナリオを指定可能
- ハーネス本体を編集せずに多様なテストが可能
- 手動テストが不要（自動化）
- TTYが必要なコードを確実にテスト
- CI/CDで実行可能
- クラッシュの再現と修正確認が容易

**実用例**：

```bash
# 新規ファイル作成と保存のテスト
zig run test_harness_generic.zig -lc -- "line 1" "Enter" "line 2" "C-x" "C-s" "/tmp/test.txt" "Enter" "C-x" "C-c"

# 編集とキャンセルのテスト（C-gでキャンセル）
zig run test_harness_generic.zig -lc -- "test" "C-x" "C-g"

# ファイル名入力のバックスペーステスト
zig run test_harness_generic.zig -lc -- "text" "C-x" "C-s" "/tmp/wrong" "Backspace" "Backspace" "Backspace" "Backspace" "Backspace" "right.txt" "Enter" "C-x" "C-c"
```

## アーキテクチャの要点

### コアデータ構造

1. **Buffer (buffer.zig)**: Piece Table + B-tree
   - 元ファイルはmmap（読み取り専用、ゼロコピー）
   - 追加バッファはArenaアロケータ（フラグメンテーションなし）
   - B-treeで行番号→pieceオフセットの索引（遅延、オンデマンド）

2. **View (view.zig)**: ダブルバッファセル、差分のみレンダリング
   - フロント/バックバッファを使用
   - 変更されたセルのみ出力（差分レンダリング）
   - 1フレームあたり1回のwrite()システムコール

3. **Input (input.zig)**: 専用入力スレッド
   - epoll/kqueue使用
   - ロックフリーキューでメインスレッドと通信
   - 投機的レンダリング：文字入力時に即座に描画してからバッファ更新

4. **Search (search.zig)**: SIMD検索エンジン
   - リテラル検索にSIMD命令使用
   - 1MBチャンクに分割して並列検索
   - インクリメンタル検索対応

### パフォーマンス目標（競合製品を超える）

| 指標 | 目標値 | 競合参考値 |
|------|--------|-----------|
| 起動時間 | < 10ms | Vim: 50-100ms, Helix: 30ms |
| キー入力から画面更新 | < 8ms (125fps) | Vim: 16ms, Helix: 10ms |
| ファイルオープン (1GB) | < 100ms | Vim: 500ms+ |
| 検索速度 (1GB) | > 2GB/s | ripgrep: 2-3GB/s |
| メモリオーバーヘッド | ファイルサイズの約10% | Vim: 50-100% |

**測定方針**:
- 定期的にベンチマークを取る
- 競合製品と比較して退化を許さない
- 体感速度を最重視（数値だけでなく「気持ち良さ」）

## コマンドシステム

### 文法

```
command := source? pipe* sink?
```

### ソース指定子

- `.` または `%`: バッファ全体
- `,`: 選択範囲
- `;`: 現在行
- `n,m`: 行範囲
- `@x`: レジスタx

### シンク指定子

- `.`: バッファ置換
- `,`: 選択範囲置換
- `+`: カーソル位置に挿入
- `_`: 破棄
- `@x`: レジスタxに保存
- `new`, `vs`, `sp`: 新規バッファ/分割

### 例

```
, | sort > .          # 選択範囲をソートしてバッファに置換
; | sh > +            # 現在行をシェル実行して下に挿入
. | grep TODO         # バッファをgrepして新規バッファに
, | jq . > ,          # 選択範囲をjqでフォーマット
```

## 実装の優先順位

Phase 1（現在）では以下を実装：
- Piece tableバッファ
- 基本レンダリング
- Emacs移動キー（C-f, C-b, C-n, C-p, C-a, C-e等）
- 挿入/削除
- ファイルI/O

## コーディングガイドライン

### 基本原則

- **パフォーマンス最優先**: 8ms以内の応答性を維持
- **ゼロコピー**: 可能な限りmmapとスライスを使用
- **comptime活用**: キーマップテーブル等はコンパイル時に解決
- **アロケーション最小化**: Arena/固定バッファ使用
- **SIMD最適化**: 検索等の高速化にSIMD命令を活用
- **シンプルさ**: Unix哲学に従い、1つのことを上手く行う

### 「あるべき姿」の追求

このプロジェクトでは、機能の理論的に最適な実装（「あるべき姿」）を追求します：

- **最適化の妥協を避ける**: 「十分速い」ではなく「理論的に最速」を目指す
- **段階的な改善**: まず動くものを作り、次に最適化する（premature optimizationは避ける）
- **複雑さとのバランス**: ただし以下の場合は「あるべき姿」を諦める
  - コードが極端に複雑になる（理解困難、保守困難）
  - コード量が2倍以上になる
  - 実測で効果が10%未満

#### 実装例：セルレベル差分描画

「行単位の差分描画」から「セルレベル差分描画」への改善：
- 前フレームの画面状態を保持（メモリコスト: 数KB）
- バイト単位で差分検出して変更部分のみ描画
- **効果**: ターミナル出力量40-90%削減、体感できる速度向上
- **複雑さ**: 許容範囲（約100行の追加、ロジックは明快）
- **結論**: 実装すべき ✅

このように、効果が明確で複雑さが許容範囲なら、積極的に「あるべき姿」を実装してください。

### さらなる最適化の方向性

常に速度向上の機会を探してください：

#### 起動時間の短縮
- **遅延初期化**: 使われるまで初期化しない
- **comptime計算**: キーマップ等をコンパイル時に解決
- **静的リンク**: 動的ライブラリ読み込みを回避

#### レンダリングの高速化
- ✅ セルレベル差分描画（実装済み）
- **ダブルバッファリング**: フロント/バックバッファで描画と表示を分離
- **バッチ書き込み**: 複数の変更を1回のwrite()にまとめる
- **ANSI最適化**: エスケープシーケンスを最短に

#### 入力処理の最適化
- **投機的レンダリング**: キー入力を先読みして即座に描画
- **キーリピート検出**: 連続入力時の最適化パス
- **専用入力スレッド**: ブロッキングI/Oを別スレッドで

#### メモリ最適化
- **Arena allocator**: 細かいアロケーションを一括管理
- **固定バッファ**: 頻繁に使うバッファは事前確保
- **mmap活用**: 大きなファイルはゼロコピー

#### プロファイリングの習慣
```bash
# 定期的にプロファイル
hyperfine --warmup 3 './zig-out/bin/ze test.txt'
perf record ./zig-out/bin/ze test.txt
```

「ここはもっと速くできるはず」と常に疑ってください。

## ファイル構造

```
ze/
├── src/
│   ├── main.zig          # エントリポイント
│   ├── editor.zig        # エディタコア状態
│   ├── buffer.zig        # Piece table実装
│   ├── view.zig          # レンダリング、画面管理
│   ├── input.zig         # 入力処理、キーパース
│   ├── command.zig       # コマンドパーサー、実行器
│   ├── search.zig        # 検索エンジン (SIMD)
│   ├── terminal.zig      # 端末制御
│   ├── window.zig        # ウィンドウ/分割管理
│   ├── keymap.zig        # キーバインディング定義
│   ├── builtin.zig       # 組み込みコマンド
│   ├── pipe.zig          # パイプライン実行
│   └── util/
│       ├── arena.zig     # Arenaアロケータ
│       ├── btree.zig     # B-tree索引
│       ├── queue.zig     # ロックフリーキュー
│       └── simd.zig      # SIMDユーティリティ
├── build.zig
├── README.md
└── config/
    └── default.zig       # デフォルト設定、エイリアス
```

## 非目標（絶対に実装しない）

以下の機能は**永久に実装しません**。機能追加の誘惑に負けないこと：

### IDE的機能（実装禁止）
- ❌ シンタックスハイライト：色付けは不要、テキストはテキスト
- ❌ LSP統合：補完、定義ジャンプ等は別のツールで
- ❌ デバッガ統合：gdb/lldbを使え
- ❌ ビルドシステム：makeやビルドツールを直接使え
- ❌ プロジェクト管理：ファイルはファイル、管理は不要

### 拡張性（実装禁止）
- ❌ プラグインシステム：拡張できない = シンプルに保てる
- ❌ スクリプト言語埋め込み：Lua、JavaScript等は不要
- ❌ 外部モジュール読み込み：動的ロード、プラグインAPI等は不要

### UI的機能（実装禁止）
- ❌ マウスサポート：キーボードのみ、マウスは邪魔
- ❌ GUI：ターミナルのみ、GUIは別のツールで
- ❌ ファイルツリー：lsやfzfを使え
- ❌ タブ表示：複数ファイルはtmux/screen分割で

### 「便利」機能（実装禁止）
- ❌ Git統合：gitコマンドを直接使え
- ❌ ターミナルエミュレータ内蔵：tmuxがある
- ❌ マクロシステム：シェルスクリプトを書け
- ❌ AI補完：Copilot等は別のツールで

**方針**: 「これあると便利かも」は全て却下。zeは**編集だけ**。

## 設定ファイルの方針

設定ファイルは**最小限**で許可します：

### デフォルトのキーバインド：Emacs-like

**デフォルトはEmacs風キーバインド**。理由：

- **モードレス**: モード切り替えが不要、シンプル
- **直感的**: C-f（前進）、C-b（後退）、C-n（次行）、C-p（前行）
- **実装がシンプル**: Vimのような複雑なモード管理が不要
- **市場の空白**: 軽くてモダンなEmacs風エディタは少ない

Vimモードは実装しない：
- モードが多すぎる（Normal/Insert/Visual/Command...）
- コマンドが膨大（実装・保守が複雑化）
- Vimユーザーは既にVim/Neovimを使っている

### 許可する設定
- ✅ **キーバインディング**: 個別キーの割り当て変更（Emacs風の範囲内）
- ✅ **基本動作**: タブ幅、インデント、改行コード
- ✅ **表示**: 行番号表示、カーソル形状
- ✅ **色**: ステータスバー、カーソル行ハイライト（最小限）

### 禁止する設定
- ❌ **拡張機能**: プラグイン、外部スクリプト実行
- ❌ **言語別設定**: 言語ごとの細かい挙動変更
- ❌ **複雑な条件**: if文だらけの設定ロジック
- ❌ **UI要素**: ツールバー、サイドバー（そもそも存在しない）

### 設計原則
```
デフォルトで十分。設定は「念のため」。
```

- **デフォルトで一般的な使い方ができる**: 設定なしでも満足できる
- **設定項目は10-20個以内**: アホみたいに増やさない
- **設定ファイルは1つ**: `~/.config/ze/config` のみ
- **シンプルな形式**: JSON/TOML等、人間が読み書きしやすい

**目標**: 「設定見なくても使える。でも必要なら変えられる。」
