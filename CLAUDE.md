# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

**ze** (Zig Editor / Zero-latency Editor) は、mgとUnix哲学に影響を受けた、高速で最小限のテキストエディタです。Zigで実装され、Emacsキーバインディングとシェル統合を特徴とします。

### プロジェクトの核心：速度への執着

このプロジェクトの最優先事項は**速度**です：

- **他製品より速く**: Vim、Helix、Kilo等の既存エディタと比較して、起動・レスポンス・操作感すべてで勝つ
- **小気味良い動作**: ユーザーが「速い！」と体感できるレベルの高速性
- **しがらみのない革新**: 既存実装にとらわれず、理論的に最速の方法を追求
- **ガンガン最適化**: 速度のためなら大胆なリファクタリングも躊躇しない

速度は機能ではなく、このエディタの**存在意義**です。

### zeの位置づけ：VSCodeのアンチテーゼ

zeは「重くなったVSCode」への回答です：

- **単純なテキストエディタ**: IDEではない、軽量な編集ツール
- **Unix編集作業**: サーバーの設定ファイル、ちょっとしたコード修正
- **拡張性は持たせない**: プラグインシステム、LSP統合、拡張機能は実装しない
- **シンプルに保つ**: 「ちょっとサーバーの編集するか」でサクッと起動・編集

**典型的なユースケース**:
```bash
ssh server
ze /etc/nginx/nginx.conf    # 設定をサクッと編集
ze script.sh                 # シェルスクリプトをちょこっと修正
```

Vim/Emacsのような「全部入り環境」を目指さない。zeは**Unix的な道具の1つ**。

## 開発状態

現在は設計・初期実装フェーズ（Phase 1）です。README.mdに詳細な設計書があります。

**重要**: このプロジェクトは未リリースの開発初期段階です。以下の方針で開発してください：

- **破壊的変更OK**: 後方互換性は一切考慮不要です
- **大胆なリファクタリング歓迎**: より良い設計があれば躊躇なく全面的に書き直してください
- **パフォーマンス優先**: 正しさとパフォーマンスのためなら、既存コードを完全に捨てて構いません
- **API変更自由**: 関数シグネチャ、構造体レイアウト、全て自由に変更可能です

### 速度最適化に対するポリシー

zeの目標は**シングルバイナリで起動が速く、入力待ちがなくキビキビ動くEmacs風エディタ**です。

**積極的に採用するもの**:
- 内部構造を変えることで速度が確実に向上する最適化
- 影響範囲が広くても、効果が明確な改善
- データ構造の根本的な変更（Piece Table、レンダリングパイプライン等）
- アロケーション削減、キャッシュ効率改善

**採用しないもの**:
- GPU依存、FFI依存（シングルバイナリの原則に反する）
- 外部ライブラリ依存（Zigの標準ライブラリのみ使用）
- コードが理解困難なほど複雑になる最適化

**判断基準**:
- 「複雑すぎるから見送り」より「効果があるなら実装」を基本とする
- ユーザーがいないので既存コードへの固執は不要
- 迷ったら速い方を選ぶ

### 体感速度の重視

**キー入力に対する即座の反応**を最優先する。

ユーザーがキーを押したとき、何も反応がないのは最悪の体験。たとえ内部処理に時間がかかっても：
- **まず画面を更新する**（文字入力なら即座に表示）
- **重い処理は後回し**（バッファ更新、インデックス再構築等）
- **フィードバックを返す**（処理中なら何か表示する）

数値的な速度（ms）より、**「押したら即反応する」という体感**を重視する。ベンチマークで速くても、ユーザーが「遅い」と感じたら意味がない。

## プロセス終了時の注意

**絶対に`pkill -f "ze"`を使わないこと！**

Chromeのコマンドライン引数に`--enable-zero-copy`が含まれており、`pkill -f "ze"`を実行するとChromeのレンダラープロセスが巻き添えで終了する。

プロセスを終了する必要がある場合：
- `pkill -f "zig-out/bin/ze"` (フルパス指定)
- または `ps aux | grep "zig-out/bin/ze"` でPIDを特定して個別に終了
- **`pkill -9 -f`の乱用は禁止** - 必ず対象を正確に指定すること

## ビルドとテスト

```bash
# ビルド
zig build

# リリースビルド（最適化）
zig build -Doptimize=ReleaseFast

# ユニットテスト実行
zig build test

# 実行
./zig-out/bin/ze [file]

# 統合テストスイート
./run_all_tests.sh

# zeやテストハーネス実行後にターミナル状態をリセット
# （代替画面終了、マウス無効化、カーソル表示）
printf '\e[?1049l\e[?1000l\e[?1003l\e[?1006l\e[?25h'
```

### ユニットテストの構成

テストファイルは `tests/` ディレクトリに配置し、`src/` と同じディレクトリ構造を維持する：

```
src/buffer.zig           → tests/buffer_test.zig
src/unicode.zig          → tests/unicode_test.zig
src/services/minibuffer.zig → tests/services/minibuffer_test.zig
```

**テストファイルの命名規則**: `<元ファイル名>_test.zig`

**テスト追加時の手順**:
1. `tests/` に対応するテストファイルを作成（または既存ファイルに追加）
2. `build.zig` の `test_files` 配列にパスを追加
3. 必要なモジュールが `imports` に含まれているか確認
4. `zig build test` で全テストが通ることを確認

**ソースファイルにテストを書かない理由**:
- テストコードがプロダクションバイナリに含まれない
- テストの依存関係が明確になる
- テストファイルの変更がプロダクションコードの再コンパイルを引き起こさない

### リリース手順

**重要**: 以下のチェックリストを**必ず順番通りに**実行すること。1つでも忘れるとリリースが壊れる。

#### チェックリスト（必須）

```
□ 1. build.zig.zon のバージョンを更新
□ 2. CHANGELOG.md に変更内容を記録
□ 3. 両方をコミット
□ 4. タグを作成してプッシュ
```

#### 手順詳細

**1. build.zig.zon** - バージョン番号を更新（**絶対に忘れるな**）
```zig
.version = "1.0.5",  // ← 必ず更新
```

**2. CHANGELOG.md** - 変更内容を記録
```markdown
## [1.0.5] - YYYY-MM-DD

### Added
- 新機能の説明

### Fixed
- バグ修正の説明
```

**3. コミット** - 両方を1つのコミットに
```bash
git add build.zig.zon CHANGELOG.md
git commit -m "chore: bump version to 1.0.5"
```

**4. タグを作成してプッシュ**
```bash
git tag -a v1.0.5 -m "v1.0.5: 簡潔な説明"
git push origin main --tags
```

#### タグを間違えた場合の修正

```bash
# ローカルとリモートのタグを削除
git tag -d v1.0.5
git push origin :refs/tags/v1.0.5

# 新しいタグを作成してプッシュ
git tag -a v1.0.5 -m "v1.0.5: 説明"
git push origin main --tags
```

#### GitHub Actionsが自動実行

- 各プラットフォーム向けバイナリをビルド
- checksums.txtを生成
- Homebrew formula (ze.rb) を生成
- GitHubリリースを作成
- homebrew-zeリポジトリを更新

### 統合テストスイート

すべての機能を網羅する自動テストスイート (106テスト、22カテゴリ):

```bash
# 全テスト実行 (約1-2分)
./run_all_tests.sh

# テストデータのセットアップ (初回のみ)
cd test_data && ./setup_test_files.sh
```

**テストカテゴリ**:
1. 基本的な編集操作 (4テスト)
2. カーソル移動 (6テスト)
3. ファイル操作 (3テスト)
4. 検索機能 (3テスト)
5. 日本語対応 (4テスト)
6. 絵文字対応 (3テスト)
7. 長い行の処理 (3テスト)
8. 大量行の処理 (3テスト)
9. ページスクロール (3テスト)
10. エッジケース (4テスト)
11. Undo/Redo機能 (6テスト)
12. 範囲選択とコピー/カット/ペースト (6テスト)
13. 単語移動と削除 (6テスト)
14. Emacsスタイルカーソル移動 (6テスト)
15. 削除操作 (6テスト)
16. 後方検索 (4テスト)
17. 複合操作とエッジケース (6テスト)
18. 日本語とUTF-8詳細テスト (6テスト)
19. ファイル操作詳細 (5テスト)
20. ストレステストと境界値 (6テスト)
21. Query Replace (M-%) (9テスト)
22. 検索履歴 (4テスト)

### PTYテストハーネス（自動E2Eテスト）

`test_harness_generic.zig`を使用して、実際のzeを擬似TTY上で起動してテストできます：

```bash
# 基本的な使い方：キーシーケンスを引数として渡す
zig run test_harness_generic.zig -lc -- "hello" "C-x" "C-s" "/tmp/test.txt" "Enter" "C-x" "C-c"

# 既存ファイルを開いて編集
zig run test_harness_generic.zig -lc -- --file=/tmp/existing.txt "C-e" " world" "C-x" "C-s" "C-x" "C-c"

# タイミング調整（待機500ms、キー間遅延100ms）
zig run test_harness_generic.zig -lc -- --wait=500 --delay=100 "hello" "Enter"

# ze の出力を表示（デバッグ時に有用）
zig run test_harness_generic.zig -lc -- --show-output "test" "C-x" "C-c"
```

**重要：ハーネスが動かない場合はハーネス自体も修正すること**

機能の実装やバグ修正時、ハーネスでテストして問題が見つかった場合：
1. **まずzeのコードを修正**
2. **ハーネスでテストが通らない場合、ハーネス自体も修正**
3. 両方が正しく動作することを確認してから完了とする

ハーネスの問題例と修正例：
- タイムアウトしてハング → タイムアウト処理と強制終了を追加
- クラッシュを検出できない → 出力をパースしてクラッシュを検出
- 特定のキーシーケンスが送れない → parseKeySequenceを拡張

**方針**: ハーネスは「動作確認の自動化」が目的。ハーネスが使えなければ手動テストに戻ってしまう。ハーネスを常に改善し続けること。

### テストのトラブルシューティング

**重要: テストが失敗したら、まず本体のバグを疑え**

テストがタイムアウトしたり失敗した場合、「テストハーネスの問題」と決めつけずに、**まずze本体のバグを疑ってください**。

#### デバッグ手順

1. **`--show-output`で出力を確認**
   ```bash
   zig run test_harness_generic.zig -lc -- --show-output --file=test.txt "M-%" "hello" "Enter" "world" "Enter" "!" "C-x" "C-c" "n"
   ```
   - 何が画面に表示されているか確認
   - 入力した文字が表示されているか？
   - エラーメッセージが出ていないか？

2. **手動で同じ操作を試す**
   ```bash
   ./zig-out/bin/ze test.txt
   # テストと同じキーシーケンスを手動で入力
   ```
   - 手動でも同じ問題が起きるか確認
   - 手動で動作するならハーネスの問題
   - 手動でも失敗するなら本体のバグ

3. **根本原因を調査**
   - タイムアウト = 何かの入力待ちでハング → 本体のバグの可能性大
   - クラッシュ = 明らかに本体のバグ
   - 予期しない動作 = 本体のロジックバグ

#### 実例：日本語置換テストのケース

**症状**: テスト21.10（日本語置換）がタイムアウト
**初期の誤判断**: 「日本語をハーネスで渡すのが困難」→ スキップ
**実際の原因**: Query Replaceモードで`.codepoint`キーを処理していなかった（本体のバグ）

**正しいアプローチ**:
1. `--show-output`で確認 → 日本語が表示されていない
2. 手動テスト → 同じ問題を確認
3. コード調査 → `src/editor.zig`で`.char`のみ処理、`.codepoint`が未処理
4. 修正 → `.codepoint`ケースを追加
5. 解決 → テストが通るようになった

**教訓**: 「できない」と諦める前に、**なぜできないのか**を徹底的に調査すること。

#### よくある問題と対処法

| 症状 | 原因の可能性 | 確認方法 |
|------|------------|---------|
| タイムアウト | 入力待ちでハング | `--show-output`で最後の状態を確認 |
| 予期しない終了 | モード処理のバグ | 手動で同じ操作を試す |
| 文字が表示されない | UTF-8処理のバグ | エスケープシーケンスを確認 |
| キーが効かない | キーバインドの未実装 | `src/editor.zig`を確認 |

#### テストハーネスの改善

本体のバグでないことが確認できたら、ハーネス自体を改善：
- `--input-file`オプションでファイルからキーシーケンス読み込み（シェルクォート問題の回避）
- タイムアウト時間の調整（`--wait`, `--delay`オプション）
- 新しいキータイプのサポート追加（`parseKeySequence()`を拡張）

**重要：新規キーバインドを追加したら必ずハーネスにも追加すること**

zeに新しいキーバインド（例：C-/、M-delete等）を実装したら、**必ず同時に** `test_harness_generic.zig` の `parseKeySequence()` 関数にそのキーのサポートを追加してください。

これを守らないと：
- ❌ 統合テストでその機能をテストできない
- ❌ リグレッションを見逃す可能性がある
- ❌ 後で気づいて慌てて追加することになる

**手順**：
1. zeのeditor.zigに新しいキーバインドを追加
2. test_harness_generic.zigの`parseKeySequence()`にそのキーのパース処理を追加
3. 両方を同じコミットに含める

**例**：C-/（Redo）を追加する場合
```zig
// test_harness_generic.zig
else if (char == '/' or char == '_')
    31 // C-/ と C-_ は 0x1f (31)
```

**特殊キーの指定方法**：
- `C-<char>`: Ctrl+文字（例: `C-x`, `C-s`, `C-g`, `C-/`, `C-@`）
- `M-<char>`: Alt+文字（例: `M-f`, `M-b`, `M-w`, `M-delete`）
- `C-Space`: Ctrl+Space（マーク設定）
- `Enter`, `Backspace`, `Tab`, `Escape`: 各特殊キー
- `Up`, `Down`, `Left`, `Right`, `Home`, `End`: 矢印キー、ナビゲーション
- 通常文字列: そのまま入力（例: `"hello world"`）

**オプション**：
- `--file=<path>`: 指定したファイルを開いて起動
- `--wait=<ms>`: 起動後のキー送信前待機時間（デフォルト: 500ms）
- `--delay=<ms>`: キー間の遅延（デフォルト: 100ms）
- `--show-output`: zeの出力を表示

**テストハーネスの仕組み**：
- POSIXの`openpty()`で擬似TTYを作成
- `fork()`で子プロセスとしてzeを起動
- コマンドライン引数で指定されたキーシーケンスを送信
- クラッシュやエラーを検出

**利点**：
- コマンドライン引数で柔軟にテストシナリオを指定可能
- ハーネス本体を編集せずに多様なテストが可能
- 手動テストが不要（自動化）
- TTYが必要なコードを確実にテスト
- CI/CDで実行可能
- クラッシュの再現と修正確認が容易

**実用例**：

```bash
# 新規ファイル作成と保存のテスト
zig run test_harness_generic.zig -lc -- "line 1" "Enter" "line 2" "C-x" "C-s" "/tmp/test.txt" "Enter" "C-x" "C-c"

# 編集とキャンセルのテスト（C-gでキャンセル）
zig run test_harness_generic.zig -lc -- "test" "C-x" "C-g"

# ファイル名入力のバックスペーステスト
zig run test_harness_generic.zig -lc -- "text" "C-x" "C-s" "/tmp/wrong" "Backspace" "Backspace" "Backspace" "Backspace" "Backspace" "right.txt" "Enter" "C-x" "C-c"
```

## リリース手順

**⚠️ 絶対に忘れるな：CHANGELOG.md の更新 ⚠️**

リリース時は以下の手順を**必ず全て**実行すること：

```bash
# 1. CHANGELOG.md を更新（これを忘れるな！）
#    - 新しいバージョンのセクションを追加
#    - Changed, Fixed, Added, Refactored 等を記載

# 2. build.zig.zon のバージョンを更新
#    .version = "X.Y.Z",

# 3. コミット
git add CHANGELOG.md build.zig.zon
git commit -m "chore: bump version to vX.Y.Z"

# 4. タグ作成とプッシュ
git tag vX.Y.Z
git push origin main --tags

# 5. GitHub Actions が自動でリリースを作成
#    - バイナリビルド（macOS/Linux × arm64/amd64）
#    - Homebrew formula 更新

# 6. リリースノートを更新（任意）
gh release edit vX.Y.Z --notes "..."
```

**チェックリスト（リリース前に確認）：**
- [ ] CHANGELOG.md に新バージョンのエントリを追加したか？
- [ ] build.zig.zon のバージョンを更新したか？
- [ ] ビルドとテストが通るか？（`zig build && zig build test`）

## アーキテクチャの要点

### コアデータ構造

1. **Buffer (buffer.zig)**: Piece Table + B-tree
   - 元ファイルはmmap（読み取り専用、ゼロコピー）
   - 追加バッファはArenaアロケータ（フラグメンテーションなし）
   - B-treeで行番号→pieceオフセットの索引（遅延、オンデマンド）

2. **View (view.zig)**: ダブルバッファセル、差分のみレンダリング
   - フロント/バックバッファを使用
   - 変更されたセルのみ出力（差分レンダリング）
   - 1フレームあたり1回のwrite()システムコール

3. **Input (input.zig)**: 非同期入力処理
   - epoll/kqueue使用（入力待機中はCPU消費なし）
   - バッファ付きリーダーで大量入力を効率的に処理
   - 100msタイムアウトでシェルコマンドのポーリングと並行

4. **Search (search.zig)**: 検索エンジン
   - リテラル検索: Buffer直接検索（コピーなし）
   - 正規表現検索: 1MB範囲制限で体感速度維持
   - インクリメンタル検索対応（C-s/C-r）

### パフォーマンス目標（競合製品を超える）

| 指標 | 目標値 | 競合参考値 |
|------|--------|-----------|
| 起動時間 | < 10ms | Vim: 50-100ms, Helix: 30ms |
| キー入力から画面更新 | < 8ms (125fps) | Vim: 16ms, Helix: 10ms |
| ファイルオープン (1GB) | < 100ms | Vim: 500ms+ |
| 検索速度 (1GB) | > 2GB/s | ripgrep: 2-3GB/s |
| メモリオーバーヘッド | ファイルサイズの約10% | Vim: 50-100% |

**測定方針**:
- 定期的にベンチマークを取る
- 競合製品と比較して退化を許さない
- 体感速度を最重視（数値だけでなく「気持ち良さ」）

## Shell Integration (C-;)

外部コマンドとの連携。zeは編集だけ、処理はUnixコマンドに任せる。

### 構文

```
[入力元] | コマンド [出力先]
```

### 入力元（プレフィックス）

- (なし): 選択範囲（なければ stdin 空）
- `%`: バッファ全体
- `.`: 現在行

### 出力先（サフィックス）

- (なし): Command Buffer に表示
- `>`: 入力元を置換（選択なしならカーソル位置に挿入）
- `+>`: カーソル位置に挿入
- `n>`: 新規バッファ

### 例

```
| sort >              # 選択範囲をソートして置換
% | sort >            # 全体をソートして置換
. | sh >              # 現在行をシェル実行して置換
% | jq . >            # JSON整形
% | jq . | sed 's/a/b/' >  # パイプラインも可
| grep TODO n>        # 検索結果を新規バッファに
```

### 実行モデル

- コマンド部分は `sh -c "..."` に丸投げ
- 別プロセスで実行、ノンブロッキングI/OでUIブロックなし
- C-g でキャンセル可能
- タイムアウトなし（LLM呼び出し等も待つ）

### 履歴と補完

**プレフィックス履歴マッチング**: 入力中に↑/↓を押すと、入力文字列で始まる履歴のみ表示。
```
| git       # ↑を押すと
| git push origin main   # "git"で始まる履歴のみ
```

**Tab補完**: bashの`compgen`を使ってコマンド/ファイル補完。
```
| gi<Tab>        → git
| cat /tmp/<Tab> → /tmp/内のファイル一覧
```

## 実装の優先順位

Phase 1（現在）では以下を実装：
- Piece tableバッファ
- 基本レンダリング
- Emacs移動キー（C-f, C-b, C-n, C-p, C-a, C-e等）
- 挿入/削除
- ファイルI/O

## コーディングガイドライン

### 基本原則

- **パフォーマンス最優先**: 8ms以内の応答性を維持
- **ゼロコピー**: 可能な限りmmapとスライスを使用
- **comptime活用**: キーマップテーブル等はコンパイル時に解決
- **アロケーション最小化**: Arena/固定バッファ使用
- **SIMD最適化**: 検索等の高速化にSIMD命令を活用
- **シンプルさ**: Unix哲学に従い、1つのことを上手く行う

### 絶対禁止：無断でのrevert

**ユーザーの許可なくrevertを絶対に行うな。**

- 修正が問題を引き起こしても、**勝手にrevertしない**
- revertが必要だと思ったら、**まずユーザーに確認を取る**
- revertする前に、**何が消えるか明確にリストアップする**
- コミット前の変更をrevertすると、**作業内容が完全に消える**

**過去の失敗**: レンダリングがガタガタになった際、確認なしにrevertしてマゼンタハイライト実装が消えた。

**正しい対応**:
1. 問題が発生したら、まず原因を特定
2. revertではなく、**問題部分のみを修正**
3. どうしてもrevertが必要なら、**ユーザーに相談してから**

### バグ調査の鉄則

バグ報告を受けたら「コードを読んで正しいはず」は禁止。まずテストで再現確認。

### 包括的なバグ調査プロセス

バグ調査を依頼されたら、**多角的に調査し、調査→修正のサイクルをバグが見つからなくなるまで繰り返す**こと。

**調査の観点（多角的調査）**:
1. **メモリ安全性**: use-after-free、double-free、メモリリーク
2. **境界値チェック**: 配列アクセス、オーバーフロー/アンダーフロー
3. **エラー処理**: errdefer/deferの正しい使用、スコープ問題
4. **UTF-8/Unicode処理**: 文字境界、continuation byte検証
5. **状態管理の一貫性**: 複数コンポーネント間の整合性

**調査→修正サイクル**:
```
第1回調査 → 発見したバグを修正 → ビルド・テスト
    ↓
第2回調査（検証） → 新たなバグを修正 → ビルド・テスト
    ↓
第3回調査 → バグなし確認 → 完了
```

**並列調査の推奨**:
- 大規模な調査では、複数のTaskエージェントを並列起動してファイル群を分担調査
- 例：editor.zig、buffer.zig、view.zig、commands/*.zig、services/*.zigを並列調査

**調査結果の精査**:
- エージェントの報告を鵜呑みにしない
- 報告されたバグが本当にバグか、コードを読んで確認
- 誤検出（実際には正しいコード）を見極める

### バグ修正時の徹底調査

**バグを1つ見つけたら、同じパターンのバグを全て潰してからテストすること。**

バグ修正の手順：
1. **バグを修正する**
2. **同じパターンのバグを探す**: 同様のコードが他にないか徹底的に検索
3. **全て修正する**: 見つかった類似バグを全て修正
4. **繰り返す**: 新たなパターンが見つかれば再度検索
5. **テストを実行**: 全ての類似バグがなくなったことを確認してからテスト

**例**: バイト長(`.len`)と表示幅の混同バグ
```
1. view.zig でステータスバーのパディングに .len を使っていた
2. grep で .len の使用箇所を全検索
3. editor.zig のミニバッファプロンプトでも同じ問題を発見
4. Query Replace のプロンプト長計算でも発見
5. 全て stringDisplayWidth() を使うように修正
6. 他に類似箇所がないことを確認
7. テスト実行 → 169/169 成功
```

**理由**:
- 同じ間違いは複数箇所で繰り返されていることが多い
- 1箇所だけ直して「修正完了」とすると、他の箇所が残る
- 後で同じバグを踏んで時間を無駄にする
- 徹底的に潰すことで、コードの品質が向上する

**検索パターンの例**:
```bash
# .len の使用箇所を確認（表示幅計算で誤用していないか）
grep -n "\.len" src/*.zig | grep -v "// " | less

# 特定の関数呼び出しパターン
grep -rn "prefix.len" src/
grep -rn "displayWidth\|stringDisplayWidth" src/
```

### 「あるべき姿」の追求

このプロジェクトでは、機能の理論的に最適な実装（「あるべき姿」）を追求します：

- **最適化の妥協を避ける**: 「十分速い」ではなく「理論的に最速」を目指す
- **段階的な改善**: まず動くものを作り、次に最適化する（premature optimizationは避ける）
- **複雑さとのバランス**: ただし以下の場合は「あるべき姿」を諦める
  - コードが極端に複雑になる（理解困難、保守困難）
  - コード量が2倍以上になる
  - 実測で効果が10%未満

#### 実装例：セルレベル差分描画

「行単位の差分描画」から「セルレベル差分描画」への改善：
- 前フレームの画面状態を保持（メモリコスト: 数KB）
- バイト単位で差分検出して変更部分のみ描画
- **効果**: ターミナル出力量40-90%削減、体感できる速度向上
- **複雑さ**: 許容範囲（約100行の追加、ロジックは明快）
- **結論**: 実装すべき ✅

このように、効果が明確で複雑さが許容範囲なら、積極的に「あるべき姿」を実装してください。

### さらなる最適化の方向性

常に速度向上の機会を探してください：

#### 起動時間の短縮
- **遅延初期化**: 使われるまで初期化しない
- **comptime計算**: キーマップ等をコンパイル時に解決
- **静的リンク**: 動的ライブラリ読み込みを回避

#### レンダリングの高速化
- ✅ セルレベル差分描画（実装済み）
- **ダブルバッファリング**: フロント/バックバッファで描画と表示を分離
- **バッチ書き込み**: 複数の変更を1回のwrite()にまとめる
- **ANSI最適化**: エスケープシーケンスを最短に

#### 入力処理の最適化
- ✅ **epoll/kqueue**: 入力待機中はCPU消費なし（実装済み）
- ✅ **バッファ付きリーダー**: 大量入力時のシステムコール削減（実装済み）
- **投機的レンダリング**: キー入力を先読みして即座に描画（将来）

#### メモリ最適化
- **Arena allocator**: 細かいアロケーションを一括管理
- **固定バッファ**: 頻繁に使うバッファは事前確保
- **mmap活用**: 大きなファイルはゼロコピー

#### プロファイリングの習慣
```bash
# 定期的にプロファイル
hyperfine --warmup 3 './zig-out/bin/ze test.txt'
perf record ./zig-out/bin/ze test.txt
```

「ここはもっと速くできるはず」と常に疑ってください。

### キーバインド追加時の注意

新しいキーバインドを追加する際は、**ターミナル環境での互換性**を考慮してください。

**追加前に確認すべきこと：**
1. そのキーが一般的なターミナルで送信可能か
2. OS/ウィンドウマネージャ/ターミナルエミュレータと競合しないか
3. 競合の可能性がある場合、代替キーも用意できるか

**危険なキーの例：**
- `C-;`, `C-'`, `C-:` など → 多くのターミナルで送信不可
- `C-Tab` → ブラウザ/ターミナルのタブ切り替えと競合
- `C-M-<記号>` (例: `C-M-%`) → ターミナルで送信困難

**対応方針：**
- 危険なキーを使う場合は、代替手段（C-x プレフィックス系など）も用意
- 連続操作が必要な機能は、プレフィックス系ではなく単キーで

**判断に迷う場合はユーザーに相談してください。**

## ファイル構造

```
ze/
├── src/
│   ├── main.zig          # エントリポイント
│   ├── editor.zig        # エディタコア（状態管理、モード遷移、キーディスパッチ）
│   ├── buffer.zig        # Piece table実装
│   ├── view.zig          # レンダリング、画面管理
│   ├── input.zig         # 入力処理、キーパース
│   ├── terminal.zig      # 端末制御
│   ├── keymap.zig        # キーバインディング定義
│   ├── syntax.zig        # 言語定義
│   ├── commands/         # ユーザー操作の実装（キーバインドに紐付く）
│   │   ├── edit.zig      # 編集操作 (kill, yank, indent等)
│   │   ├── movement.zig  # カーソル移動
│   │   ├── rectangle.zig # 矩形操作
│   │   └── mx.zig        # M-xコマンド実行
│   └── services/         # 独立したサブシステム（状態を持つ）
│       ├── shell_service.zig    # シェルコマンド実行
│       ├── search_service.zig   # 検索履歴管理
│       ├── buffer_manager.zig   # バッファ管理
│       ├── window_manager.zig   # ウィンドウ管理
│       └── minibuffer.zig       # ミニバッファ
├── tests/                # ユニットテスト（src/と同じ構造）
│   ├── buffer_test.zig
│   ├── editing_context_test.zig
│   ├── history_test.zig
│   ├── input_test.zig
│   ├── keymap_test.zig
│   ├── regex_test.zig
│   ├── syntax_test.zig
│   ├── unicode_test.zig
│   ├── view_test.zig
│   ├── comprehensive_test.zig
│   └── services/         # サービスのテスト
│       ├── buffer_manager_test.zig
│       ├── minibuffer_test.zig
│       ├── search_service_test.zig
│       ├── shell_service_test.zig
│       └── window_manager_test.zig
├── test_data/            # E2Eテスト用データ
├── build.zig
├── README.md
└── test_harness_generic.zig  # E2Eテストハーネス
```

## コード配置の指針

### editor.zig に置くもの

1. **状態管理**: `mode`, `windows`, `buffers`, 各種フラグ
2. **モード遷移とキーディスパッチ**: `processKey()`, `handleNormalKey()` 等
3. **複数サブシステムの協調**: シェル実行、検索等の複数コンポーネント連携

### commands/ に置くもの

**単一の操作として完結する「コマンド」** - キーバインドに紐付く操作

```zig
// シグネチャ: *Editor を受け取り、副作用を起こす
pub fn killLine(e: *Editor) !void { ... }
pub fn yankRectangle(e: *Editor) void { ... }
```

**判断基準**:
- キーバインドから直接呼ばれる
- 他のコマンドと組み合わせ可能
- Editorの状態を変更するが、モード遷移は行わない

### services/ に置くもの

**状態を持つ独立したサブシステム**

```zig
// 独自の状態を持ち、Editorに依存しない（または最小限）
pub const ShellService = struct {
    history: ArrayList([]const u8),
    process: ?std.process.Child,
    pub fn start(...) !void { ... }
    pub fn poll() ?Result { ... }
};
```

**判断基準**:
- 独自の状態（履歴、プロセス等）を持つ
- Editorに依存せずテスト可能
- 再利用可能なロジック

### 判断フローチャート

```
新しい機能を追加するとき...

1. 独自の状態を持つ独立したサブシステム？
   → YES: services/ に新規ファイル

2. キーバインドから呼ばれる単一操作？
   → YES: commands/ の適切なファイルに追加

3. 複数サブシステムの協調が必要？
   → YES: editor.zig にメソッドとして追加

4. モード遷移のロジック？
   → YES: editor.zig に追加
```

### 現状の適合状況

| ファイル | 責務 | 指針に適合 |
|---------|------|-----------|
| `editor.zig` | 状態管理、モード遷移、協調処理 | ✅ |
| `commands/edit.zig` | kill/yank/indent等の編集操作 | ✅ |
| `commands/movement.zig` | カーソル移動 | ✅ |
| `commands/rectangle.zig` | 矩形操作 | ✅ |
| `commands/mx.zig` | M-xコマンド実行 | ✅ |
| `services/shell_service.zig` | プロセス実行、履歴管理 | ✅ |
| `services/search_service.zig` | 検索履歴管理 | ✅ |
| `services/buffer_manager.zig` | バッファ管理 | ✅ |
| `services/window_manager.zig` | ウィンドウ管理 | ✅ |
| `services/minibuffer.zig` | 入力バッファ管理 | ✅ |

## 非目標（絶対に実装しない）

以下の機能は**永久に実装しません**。機能追加の誘惑に負けないこと：

### IDE的機能（実装禁止）
- ❌ シンタックスハイライト：キーワード、関数、変数等の言語構文の色分けは不要
  - ただしコメントのグレー表示は許可（設定ファイル等でも有用な最小限の視覚的区別）
- ❌ LSP統合：補完、定義ジャンプ等は別のツールで
- ❌ デバッガ統合：gdb/lldbを使え
- ❌ ビルドシステム：makeやビルドツールを直接使え
- ❌ プロジェクト管理：ファイルはファイル、管理は不要

### 拡張性（実装禁止）
- ❌ プラグインシステム：拡張できない = シンプルに保てる
- ❌ スクリプト言語埋め込み：Lua、JavaScript等は不要
- ❌ 外部モジュール読み込み：動的ロード、プラグインAPI等は不要

### UI的機能（実装禁止）
- ❌ マウスサポート：キーボードのみ、マウスは邪魔
- ❌ GUI：ターミナルのみ、GUIは別のツールで
- ❌ ファイルツリー：lsやfzfを使え
- ❌ タブ表示：複数ファイルはtmux/screen分割で

### 「便利」機能（実装禁止）
- ❌ Git統合：gitコマンドを直接使え
- ❌ ターミナルエミュレータ内蔵：tmuxがある
- ❌ マクロシステム：シェルスクリプトを書け（キーボードマクロのみ許可）
- ❌ AI補完：Copilot等は別のツールで

**方針**: 「これあると便利かも」は全て却下。zeは**編集だけ**。

## 設定ファイルの方針

設定ファイルは**最小限**で許可します：

### デフォルトのキーバインド：Emacs-like

**デフォルトはEmacs風キーバインド**。理由：

- **モードレス**: モード切り替えが不要、シンプル
- **直感的**: C-f（前進）、C-b（後退）、C-n（次行）、C-p（前行）
- **実装がシンプル**: Vimのような複雑なモード管理が不要
- **市場の空白**: 軽くてモダンなEmacs風エディタは少ない

Vimモードは実装しない：
- モードが多すぎる（Normal/Insert/Visual/Command...）
- コマンドが膨大（実装・保守が複雑化）
- Vimユーザーは既にVim/Neovimを使っている

### 許可する設定
- ✅ **キーバインディング**: 個別キーの割り当て変更（Emacs風の範囲内）
- ✅ **基本動作**: タブ幅、インデント、改行コード
- ✅ **表示**: 行番号表示、カーソル形状
- ✅ **色**: ステータスバー、カーソル行ハイライト（最小限）

### 禁止する設定
- ❌ **拡張機能**: プラグイン、外部スクリプト実行
- ❌ **言語別設定**: 言語ごとの細かい挙動変更
- ❌ **複雑な条件**: if文だらけの設定ロジック
- ❌ **UI要素**: ツールバー、サイドバー（そもそも存在しない）

### 設計原則
```
デフォルトで十分。設定は「念のため」。
```

- **デフォルトで一般的な使い方ができる**: 設定なしでも満足できる
- **設定項目は10-20個以内**: アホみたいに増やさない
- **設定ファイルは1つ**: `~/.config/ze/config` のみ
- **シンプルな形式**: JSON/TOML等、人間が読み書きしやすい

**目標**: 「設定見なくても使える。でも必要なら変えられる。」
